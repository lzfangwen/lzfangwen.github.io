<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaEE-学习笔记1</title>
    <url>/lzfangwen.github.io/2020/04/01/JavaEE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Markdown高级技巧</title>
    <url>/lzfangwen.github.io/2020/04/22/Markdown%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><code>&lt;font color="red"&gt;红色&lt;/font&gt;</code></p>
<p><font color="red">红色</font></p>
<p><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></p>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<a id="more"></a>

<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><code>**文本加粗**</code></p>
<p><strong>文本加粗</strong></p>
<p><code>\*\*正常显示星号\*\*</code></p>
<p>**正常显示星号**</p>
<h2 id="流程图、时序图（顺序图）、甘特图"><a href="#流程图、时序图（顺序图）、甘特图" class="headerlink" title="流程图、时序图（顺序图）、甘特图"></a>流程图、时序图（顺序图）、甘特图</h2><h3 id="向Hexo中插入mermaid-diagrams"><a href="#向Hexo中插入mermaid-diagrams" class="headerlink" title="向Hexo中插入mermaid diagrams"></a>向Hexo中插入mermaid diagrams</h3><p>转自教程<a href="https://wangxiaoyu-go.github.io/2018/11/23/hexo-filter-mermaid-diagrams/" target="_blank" rel="noopener">Hexo中插入mermaid diagrams</a></p>
<p><a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">Github项目</a></p>
<p><a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">官方</a></p>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p><code>npm install hexo-filter-mermaid-diagrams</code></p>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>在hexo的<code>_config.yml</code>文件（根目录的并非主题的）中，添加以下内容：</p>
<pre><code># mermaid chart
mermaid: ## mermaid url https://github.com/knsv/mermaid
  enable: true  # default true
  version: "7.1.2" # default v7.1.2
  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js
    #startOnload: true  // default true</code></pre><h4 id="js文件修改"><a href="#js文件修改" class="headerlink" title="js文件修改"></a>js文件修改</h4><ol>
<li>修改位置 （next主题为例）<br><code>themes/next/layout/_partials/footer.swig</code></li>
<li>根据footer的格式不同，添加的内容不同。<br>格式有<code>after_footer.pug</code> , <code>after-footer.ejs</code> ,<code>footer.swig</code>等。<br>以下在next的<code>footer.swig</code>添加的内容。其他格式参考<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">github: hexo-filter-mermaid-diagrams</a></li>
</ol>
<blockquote>
<pre><code>{% if theme.mermaid.enable %}
&gt;   <script src="https://unpkg.com/mermaid@{{ theme.mermaid.version }}/dist/mermaid.min.js"></script>
&gt;   <script>
>     if (window.mermaid) {
>       mermaid.initialize({{ JSON.stringify(theme.mermaid.options) }});
>     }
>   </script>
&gt; {% endif %}</code></pre></blockquote>
<p>到此为止，设置的部分就结束了。</p>
<h4 id="个性化背景颜色"><a href="#个性化背景颜色" class="headerlink" title="个性化背景颜色"></a>个性化背景颜色</h4><p>个人希望没有背景颜色，是透明的。<br>hexo有供用户设置的css文件。需要在这里添加需要的css内容。</p>
<ul>
<li>文件位置（next主题为例）<br><code>themes\next\source\css\_custom\custom.styl</code></li>
<li>添加内容</li>
</ul>
<pre><code>.mermaid {
 background: transparent;
}</code></pre><h3 id="流程图-Flow-Chart"><a href="#流程图-Flow-Chart" class="headerlink" title="流程图 Flow Chart"></a>流程图 Flow Chart</h3><p><a href="http://www.guide2it.com/post/2019-03-10-1-make-flowcharts-with-mermaid-in-markdown/" target="_blank" rel="noopener">Hexo+Mermaid(一)：记住三、四、五，玩转Mermaid流程图</a></p>
<blockquote>
<p>```mermaid<br>graph LR<br>A[方形] –&gt;B(圆角)<br>    B –&gt; C{条件a}<br>    C –&gt;|a=1| D[结果1]<br>    C –&gt;|a=2| E[结果2]<br>    F[横向流程图]<br>```</p>
</blockquote>
<pre class="mermaid">graph LR
A[方形] --&gt;B(圆角)
    B --&gt; C{条件a}
    C --&gt;|a=1| D[结果1]
    C --&gt;|a=2| E[结果2]
    F[横向流程图]</pre>
<blockquote>
<p>```mermaid<br>graph TD<br>A[方形] –&gt; B(圆角)<br>    B –&gt; C{条件a}<br>    C –&gt; |a=1| D[结果1]<br>    C –&gt; |a=2| E[结果2]<br>    F[竖向流程图]<br>```</p>
</blockquote>
<pre class="mermaid">graph TD
A[方形] --&gt; B(圆角)
    B --&gt; C{条件a}
    C --&gt; |a=1| D[结果1]
    C --&gt; |a=2| E[结果2]
    F[竖向流程图]</pre>

<h3 id="时序图-Sequence-Diagram"><a href="#时序图-Sequence-Diagram" class="headerlink" title="时序图 Sequence Diagram"></a>时序图 Sequence Diagram</h3><p><a href="http://www.guide2it.com/post/2019-03-10-2-make-sequence-diagrams-with-mermaid-in-markdown/" target="_blank" rel="noopener">Hexo+Mermaid(二)：六步玩转Mermaid时</a></p>
<blockquote>
<p>```mermaid<br>%% 时序图例子,-&gt; 直线，–&gt;虚线，-&gt;&gt;实线箭头<br>  sequenceDiagram<br>    participant 张三<br>    participant 李四<br>    张三-&gt;王五: 王五你好吗？<br>    loop 健康检查<br>        王五-&gt;王五: 与疾病战斗<br>    end<br>    Note right of 王五: 合理 食物 <br>看医生…<br>    李四–&gt;&gt;张三: 很好!<br>    王五-&gt;李四: 你怎么样?<br>    李四–&gt;王五: 很好!<br>```</p>
</blockquote>
<pre class="mermaid">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头
  sequenceDiagram
    participant 张三
    participant 李四
    张三-&gt;王五: 王五你好吗？
    loop 健康检查
        王五-&gt;王五: 与疾病战斗
    end
    Note right of 王五: 合理 食物 <br>看医生...
    李四--&gt;&gt;张三: 很好!
    王五-&gt;李四: 你怎么样?
    李四--&gt;王五: 很好!</pre>
<h3 id="甘特图-Gantt-chart"><a href="#甘特图-Gantt-chart" class="headerlink" title="甘特图 Gantt chart"></a>甘特图 Gantt chart</h3><p><a href="http://www.guide2it.com/post/2019-03-10-3-make-gantt-with-mermaid-in-markdown/" target="_blank" rel="noopener">Hexo+Mermaid(三)：用Mermaid在Hexo中实现超简单的甘特图</a></p>
<blockquote>
<p>```mermaid<br>gantt<br>    title A Gantt Diagram<br>    dateFormat  YYYY-MM-DD<br>    section Section<br>    A task           :a1, 2014-01-01, 30d<br>    Another task     :after a1  , 20d<br>    section Another<br>    Task in sec      :2014-01-12  , 12d<br>    another task      : 24d<br>```</p>
</blockquote>
<pre class="mermaid">gantt
    title A Gantt Diagram
    dateFormat  YYYY-MM-DD
    section Section
    A task           :a1, 2014-01-01, 30d
    Another task     :after a1  , 20d
    section Another
    Task in sec      :2014-01-12  , 12d
    another task      : 24d</pre>

<blockquote>
<p>```mermaid<br>gantt<br>        dateFormat  YYYY-MM-DD<br>        title 软件开发甘特图<br>        section 设计<br>        需求                      :done,    des1, 2014-01-06,2014-01-08<br>        原型                      :active,  des2, 2014-01-09, 3d<br>        UI设计                     :         des3, after des2, 5d<br>        未来任务                     :         des4, after des3, 5d<br>        section 开发<br>        学习准备理解需求                      :crit, done, 2014-01-06,24h<br>        设计框架                             :crit, done, after des2, 2d<br>        开发                                 :crit, active, 3d<br>        未来任务                              :crit, 5d<br>        耍                                   :2d<br>        section 测试<br>        功能测试                              :active, a1, after des3, 3d<br>        压力测试                               :after a1  , 20h<br>        测试报告                               : 48h<br>```</p>
</blockquote>
<pre class="mermaid">gantt
        dateFormat  YYYY-MM-DD
        title 软件开发甘特图
        section 设计
        需求                      :done,    des1, 2014-01-06,2014-01-08
        原型                      :active,  des2, 2014-01-09, 3d
        UI设计                     :         des3, after des2, 5d
        未来任务                     :         des4, after des3, 5d
        section 开发
        学习准备理解需求                      :crit, done, 2014-01-06,24h
        设计框架                             :crit, done, after des2, 2d
        开发                                 :crit, active, 3d
        未来任务                              :crit, 5d
        耍                                   :2d
        section 测试
        功能测试                              :active, a1, after des3, 3d
        压力测试                               :after a1  , 20h
        测试报告                               : 48h</pre>

<p><a href="https://www.runoob.com/markdown/md-advance.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ string字符比较函数compare</title>
    <url>/lzfangwen.github.io/2020/03/10/C++%20string%E5%AD%97%E7%AC%A6%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0compare%20/</url>
    <content><![CDATA[<p>﻿# compare()函数</p>
<p> 在洛谷刷题时遇到一题需要使用字符串比较的题于是查了一下c++的字符比较函数，发现写的都比较复杂，我看不太懂<del>随便写写 ~</del>copy<del>~ 便于自己复习<br>  ~</del>可能有错误不要打我~~ </p>
<a id="more"></a>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>若参与比较的两个串值(也就是ASCII值)相同，则函数返回 0；若字符串 S 按字典顺序要先于 S2，则返回负值；反之，则返回正值。比较方法为从两个字符串开始比较的位置一个个字符顺序相比ASCII值。<br>常见ASCII码的大小规则：0-9 &lt; A-Z &lt; a-z。<br>1）数字比字母要小。如 “7”&lt;“F”；<br>2）数字0比数字9要小，并按0到9顺序递增。如 “3”&lt;“8” ；<br>3）字母A比字母Z要小，并按A到Z顺序递增。如“A”&lt;“Z” ；<br>4）同个字母的大写字母比小写字母要小32。如“A”&lt;“a” 。<br>几个常见字母的ASCII码大小： “A”为65；“a”为97；“0”为 48<br>下面举例说明如何使用 string 类的 compare() 函数。</p>
<ol>
<li>s.compare(n)</li>
</ol>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;//字符串函数嘛 肯定要字符串头文件啦 
using namespace std;
int main()
{
    string s("abc");
    string n("Abde"); 
    cout&lt;&lt;"s.compare(n)="&lt;&lt;s.compare(n)&lt;&lt;endl ;//完整的字符串s与n比较
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020031009165424.png" alt="输出结果"><br>结果为1即字符串s&gt;n<br>字符串的创建也有很多方式 可以参考一下 <a href="https://blog.csdn.net/qq_37941471/article/details/82107077" target="_blank" rel="noopener">string字符串相关函数</a></p>
<ol start="2">
<li>s.compare(1,2,n)</li>
</ol>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;//字符串函数嘛 肯定要字符串头文件啦 
using namespace std;
int main()
{
    string s("AbDeas");
    string n("Abdeas"); 
    cout&lt;&lt;"s.compare(1,2,n)="&lt;&lt;s.compare(1,2,n)&lt;&lt;endl;//bd与Abdeas相比 
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200310094804318.png" alt="结果"><br>结果为1  bd与Abdeas相比 bd&gt;Abdeas没毛病<br>s.compare(1,2,n) 中 1代表 下表 2代表数量  意思为 s字符串中下表为1 开始 字符数量为2的字符串  bd  与n相比</p>
<ol start="3">
<li>s.compare(1,2,n,2,3)</li>
</ol>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;//字符串函数嘛 肯定要字符串头文件啦 
using namespace std;
int main()
{
    string s("Abdeas");
    string n("Abdeas"); 
    cout&lt;&lt;"s.compare(1,2,n,1,3)="&lt;&lt;s.compare(1,2,n,1,3)&lt;&lt;endl;//bd与bde相比 
}</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200310095539579.png" alt="结果"><br>结果为-1  bd&lt;bde  没毛病  这个 就表示 两个字符串的指定 字符串段 比较</p>
<p>这样 就结束了compare()函数 的使用方法<br>0，0<br>哦哦 再把我做的题放出来把 简单的应用 虽然我做的挺复杂的orz</p>
<h2 id="洛谷-P1781-宇宙总统"><a href="#洛谷-P1781-宇宙总统" class="headerlink" title="洛谷 P1781 宇宙总统"></a>洛谷 P1781 宇宙总统</h2><p><a href="https://www.luogu.com.cn/problem/P1781" target="_blank" rel="noopener">题目链接</a><br>题目描述<br>地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 nn 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。</p>
<p>输入格式<br>第一行为一个整数 nn，代表竞选总统的人数。</p>
<p>接下来有 nn 行，分别为第一个候选人到第 nn 个候选人的票数。</p>
<p>输出格式<br>共两行，第一行是一个整数 mm，为当上总统的人的号数。</p>
<p>第二行是当上总统的人的选票。</p>
<p>输入输出样例<br>输入 #1<br>5<br>98765<br>12365<br>87954<br>1022356<br>985678<br>输出 #1<br>4<br>1022356<br>说明/提示<br>票数可能会很大，可能会到 100100 位数字。<br>我的代码</p>
<pre><code class="cpp">
​```cpp
#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,mixsum;//涉及极大数问题 字符串解决
string a,mix;
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a;
        if(mix.empty()){
            mix=a;
            mixsum=i;
        }
        if(a.size()&gt;mix.size()){
            mix=a;
            mixsum=i;
        }
        else if(a.size()&lt;mix.size()){
            continue;
        }
        else if(a.size()==mix.size()){
            if(a.compare(mix)&gt;0){
                mix=a;
                mixsum=i;
            }
            else{
                continue;
            }
        }
    }
    cout&lt;&lt;mixsum&lt;&lt;endl;
    cout&lt;&lt;mix&lt;&lt;endl; 
    return 0;
}</code></pre>
<p>参考链接<br><a href="http://c.biancheng.net/view/1447.html" target="_blank" rel="noopener">C++ string字符串比较方法详解</a><br><a href="https://baike.baidu.com/item/ASCII/309296?fromtitle=ascii%E7%A0%81&amp;fromid=99077&amp;fr=aladdin" target="_blank" rel="noopener">百度百科ASCII</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客相关事项</title>
    <url>/lzfangwen.github.io/2020/03/31/hexo%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="hexo新建文章的默认值"><a href="#hexo新建文章的默认值" class="headerlink" title="hexo新建文章的默认值"></a>hexo新建文章的默认值</h2><p>博客文件夹下git bash</p>
<p><code>hexo new 文章名</code></p>
<p>会在blog\source_posts下新建一个文章 文章默认值为</p>
<p><code>title: hexo博客相关事项 ##文章标题
date: 1585631681000##文章日期
tags:           ##标签可多个 ``
categories:     ##分类最好一个``  
mathjax: flase  ##是否开启数学公式</code>  </p>
<p>默认值可以在blog\scaffolds\post.md中修改</p>
<p>文章写好后依然是博客文件夹下git bash</p>
<p><code>hexo clean</code></p>
<p><code>hexo g</code>##生成静态文件</p>
<p><code>hexo s</code>##启动服务器用于本地预览</p>
<p>输入<a href="http://localhost:4000就可以预览博客了确认没有问题再">http://localhost:4000就可以预览博客了确认没有问题再</a></p>
<p><code>hexo d</code>将本地文件发送github仓库中就可以了</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex数学公式基础</title>
    <url>/lzfangwen.github.io/2020/04/08/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>一些常用的Latex公式 转自Latex<a href="https://www.jianshu.com/p/e6d2368e451a" target="_blank" rel="noopener">数学公式基础</a>   <a href="https://www.jianshu.com/p/e6d2368e451a" target="_blank" rel="noopener">LaTeX写数学公式</a></p>
<ul>
<li><p>行内公式用<code>$...$</code>括起来，如<code>$ x^2 $</code>：$x^2$</p>
</li>
<li><p>独立公式 单独占一行，不和其他文字混编用<code>$$...$$</code>括起来，如<code>$$ f(x) = x^2 $$</code>：<br>$$<br>f(x) = x^2<br>$$</p>
</li>
<li><p>多行公式     在独立公式中使用\来换行</p>
</li>
</ul>
<pre><code>$$   
2x+3y=34\\   
x+4y=25  
$$         </code></pre><p>$$<br>2x+3y=34\<br>x+4y=25<br>$$</p>
<a id="more"></a>

<ol>
<li><p>\frac`分数</p>
<blockquote>
<p><code>\frac 1 2</code>$\frac 1 2$</p>
<p><code>\frac {2x}{x+y}</code>$\frac {2x}{x+y}$</p>
</blockquote>
</li>
<li><p><code>\partial</code>偏导</p>
<blockquote>
<p><code>\partial</code> $\partial$</p>
<p><code>\partial x</code> $\partial x$</p>
<p><code>\frac {\partial E(x)} {\partial x}</code>$\frac {\partial E(x)} {\partial x}$</p>
</blockquote>
</li>
<li><p><code>\sqrt</code>开根号</p>
<blockquote>
<p><code>\sqrt x</code>$\sqrt x$</p>
<p><code>\sqrt {x^2 + y}</code>$\sqrt {x^2 + y}$</p>
<p><code>\sqrt [n]{x}</code>$\sqrt [n]{x}$</p>
</blockquote>
</li>
<li><p><code>^</code>指数</p>
<blockquote>
<p><code>x^2</code>$x^2$</p>
<p><code>x^{a^2+b^2}</code>$x^{a^2+b^2}$</p>
</blockquote>
</li>
<li><p><code>_</code>下标、正下标</p>
<blockquote>
<p><code>x_i</code>$x_i$</p>
<p><code>x_i^2</code>$x_i^2$</p>
<p><code>x_{i+1}^2</code>$x_{i+1}^2$</p>
<p><code>\max\limits_{x\in R} f(x)</code>$\max\limits_{x\in R} f(x)$</p>
<p>如果是数学符号，那么直接用<code>\limits</code>命令百放在正下度方，如</p>
<p><code>\sum\limits_{i=1}</code>$ \sum\limits_{i=1} $</p>
<p>若是普通符号，那知么要用<code>\mathop</code>先转成数学道符号再用<code>\limits</code>，如</p>
<p><code>$ \mathop{a}\limits_{i=``1``} $</code>$ \mathop{a}\limits_{i=<code>1</code>} $</p>
</blockquote>
</li>
<li><p><code>\</code>转义字符的使用</p>
<blockquote>
<p><code>\%</code>$%$</p>
</blockquote>
</li>
</ol>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h2><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td><code>\pm</code></td>
<td>$\pm$</td>
</tr>
<tr>
<td><code>\times</code></td>
<td>$\times$</td>
</tr>
<tr>
<td><code>\div</code></td>
<td>$\div$</td>
</tr>
<tr>
<td><code>\mid</code></td>
<td>$\mid$</td>
</tr>
<tr>
<td><code>\nmid</code></td>
<td>$\nmid$</td>
</tr>
<tr>
<td><code>\cdot</code></td>
<td>$\cdot$</td>
</tr>
<tr>
<td><code>\circ</code></td>
<td>$\circ$</td>
</tr>
<tr>
<td><code>\ast</code></td>
<td>$\ast$</td>
</tr>
<tr>
<td><code>\bigodot</code></td>
<td>$\bigodot$</td>
</tr>
<tr>
<td><code>\leq</code></td>
<td>$\leq$</td>
</tr>
<tr>
<td><code>\neq</code></td>
<td>$\neq$</td>
</tr>
<tr>
<td><code>\geq</code></td>
<td>$\geq$</td>
</tr>
<tr>
<td><code>\qpprox</code></td>
<td>$\approx$</td>
</tr>
<tr>
<td><code>\equiv</code></td>
<td>$\equiv$</td>
</tr>
<tr>
<td><code>\sum</code></td>
<td>$\sum$</td>
</tr>
<tr>
<td><code>\prod</code></td>
<td>$\prod$</td>
</tr>
</tbody></table>
<h2 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符$$"></a><strong>三角运算符</strong>$$</h2><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td><code>\bot</code></td>
<td>$\bot$</td>
</tr>
<tr>
<td><code>\angle</code></td>
<td>$\angle$</td>
</tr>
<tr>
<td><code>\sin</code></td>
<td>$\sin$</td>
</tr>
<tr>
<td><code>\cos</code></td>
<td>$\cos$</td>
</tr>
<tr>
<td><code>\tan</code></td>
<td>$\tan$</td>
</tr>
<tr>
<td><code>\cot</code></td>
<td>$\cot$</td>
</tr>
<tr>
<td><code>\sec</code></td>
<td>$\sec$</td>
</tr>
<tr>
<td><code>\csc</code></td>
<td>$\csc$</td>
</tr>
</tbody></table>
<h2 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h2><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td><code>\log</code></td>
<td>$\log$</td>
</tr>
<tr>
<td><code>\lg</code></td>
<td>$\lg$</td>
</tr>
<tr>
<td><code>\ln</code></td>
<td>$\ln$</td>
</tr>
</tbody></table>
<h2 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h2><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td><code>\prime</code></td>
<td>$\prime$</td>
</tr>
<tr>
<td><code>\int</code></td>
<td>$\int$</td>
</tr>
<tr>
<td><code>\iint</code></td>
<td>$\iint$</td>
</tr>
<tr>
<td><code>\iiint</code></td>
<td>$\iiint$</td>
</tr>
<tr>
<td><code>\oint</code></td>
<td>$\oint$</td>
</tr>
<tr>
<td><code>\lim</code></td>
<td>$\lim$</td>
</tr>
<tr>
<td><code>\infty</code></td>
<td>$\infty$</td>
</tr>
<tr>
<td><code>\mathrm{d}</code></td>
<td>$\mathrm{d}$</td>
</tr>
</tbody></table>
<h2 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h2><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td><code>\emptyset</code></td>
<td>$\emptyset$</td>
</tr>
<tr>
<td><code>\in</code></td>
<td>$\in$</td>
</tr>
<tr>
<td><code>\notin</code></td>
<td>$\notin$</td>
</tr>
<tr>
<td><code>\subset</code></td>
<td>$\subset$</td>
</tr>
<tr>
<td><code>\subseteq</code></td>
<td>$\subseteq$</td>
</tr>
<tr>
<td><code>\supseteq</code></td>
<td>$\supseteq$</td>
</tr>
<tr>
<td><code>\bigcap</code></td>
<td>$\bigcap$</td>
</tr>
<tr>
<td><code>\bigcup</code></td>
<td>$\bigcup$</td>
</tr>
<tr>
<td><code>\bigvee</code></td>
<td>$\bigvee$</td>
</tr>
<tr>
<td><code>\bigwedge</code></td>
<td>$\bigwedge$</td>
</tr>
<tr>
<td><code>\biguplus</code></td>
<td>$\biguplus$</td>
</tr>
<tr>
<td><code>\bigsqcup</code></td>
<td>$\bigsqcup$</td>
</tr>
</tbody></table>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th>代码</th>
<th>大写</th>
<th>代码</th>
<th>小写</th>
</tr>
</thead>
<tbody><tr>
<td><code>A</code></td>
<td>$A$</td>
<td><code>\alpha</code></td>
<td>$\alpha$</td>
</tr>
<tr>
<td><code>B</code></td>
<td>B$</td>
<td><code>\beta</code></td>
<td>$\beta$</td>
</tr>
<tr>
<td><code>\Gamma</code></td>
<td>$\Gamma$</td>
<td><code>\gamma</code></td>
<td>$\gamma$</td>
</tr>
<tr>
<td><code>\Delta</code></td>
<td>$\Delta$</td>
<td><code>\delta</code></td>
<td>$\delta$</td>
</tr>
<tr>
<td><code>E</code></td>
<td>$E$</td>
<td>\epsilon</td>
<td>$\epsilon$</td>
</tr>
<tr>
<td><code>Z</code></td>
<td>$Z$</td>
<td><code>\zeta</code></td>
<td>$\zeta$</td>
</tr>
<tr>
<td><code>H</code></td>
<td>$H$</td>
<td><code>\eta</code></td>
<td>$\eta$</td>
</tr>
<tr>
<td><code>\Theta</code></td>
<td>$\Theta$</td>
<td><code>\theta</code></td>
<td>$\theta$</td>
</tr>
<tr>
<td><code>I</code></td>
<td>$I$</td>
<td><code>\iota</code></td>
<td>$\iota$</td>
</tr>
<tr>
<td><code>K</code></td>
<td>$K$</td>
<td><code>\kappa</code></td>
<td>$\kappa$</td>
</tr>
<tr>
<td><code>Lambda</code></td>
<td>$Lambda$</td>
<td><code>\lambda</code></td>
<td>$\lambda$</td>
</tr>
<tr>
<td><code>M</code></td>
<td>$M$</td>
<td><code>\mu</code></td>
<td>$\mu$</td>
</tr>
<tr>
<td><code>N</code></td>
<td>$N$</td>
<td><code>\nu</code></td>
<td>$\nu$</td>
</tr>
<tr>
<td><code>Xi</code></td>
<td>$Xi$</td>
<td><code>\xi</code></td>
<td>$\xi$</td>
</tr>
<tr>
<td><code>O</code></td>
<td>$O$</td>
<td><code>\omicron</code></td>
<td>$\omicron$</td>
</tr>
<tr>
<td><code>\Pi</code></td>
<td>$\Pi$</td>
<td><code>\pi</code></td>
<td>$\pi$</td>
</tr>
<tr>
<td><code>P</code></td>
<td>$P$</td>
<td><code>\rho</code></td>
<td>$\rho$</td>
</tr>
<tr>
<td><code>\Sigma</code></td>
<td>$\Sigma$</td>
<td><code>\sigma</code></td>
<td>$\sigma$</td>
</tr>
<tr>
<td><code>T</code></td>
<td>$T$</td>
<td><code>\tau</code></td>
<td>$\tau$</td>
</tr>
<tr>
<td><code>\Upsilon</code></td>
<td>$\Upsilon$</td>
<td><code>\upsilon</code></td>
<td>$\upsilon$</td>
</tr>
<tr>
<td><code>\Phi</code></td>
<td>$\Phi$</td>
<td><code>\phi</code></td>
<td>$\phi$</td>
</tr>
<tr>
<td><code>X</code></td>
<td>$X$</td>
<td><code>\chi</code></td>
<td>$\chi$</td>
</tr>
<tr>
<td><code>\Psi</code></td>
<td>$\Psi$</td>
<td><code>\psi</code></td>
<td>$\psi$</td>
</tr>
<tr>
<td><code>\Omega</code></td>
<td>$\Omega$</td>
<td><code>\omega</code></td>
<td>$\omega$</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet&amp;HTTP&amp;Request笔记</title>
    <url>/lzfangwen.github.io/2020/07/03/Servlet&amp;HTTP&amp;Request%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><ol>
<li>软件架构<ol>
<li>C/S：客户端/服务器端</li>
<li>B/S：浏览器/服务器端</li>
</ol>
</li>
</ol>
<a id="more"></a>


<ol start="2">
<li>资源分类<ol>
<li>静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析<br>如： html,css,JavaScript</li>
<li>动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器<br>如：servlet/jsp,php,asp….</li>
</ol>
</li>
</ol>
<ol start="3">
<li>网络通信三要素<ol>
<li>IP：电子设备(计算机)在网络中的唯一标识。</li>
<li>端口：应用程序在计算机中的唯一标识。 0~65536</li>
<li>传输协议：规定了数据传输的规则<br>基础协议：<ol>
<li>tcp:安全协议，三次握手。 速度稍慢</li>
<li>udp：不安全协议。 速度快</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><ul>
<li>服务器：安装了服务器软件的计算机</li>
<li>服务器软件：接收用户的请求，处理请求，做出响应</li>
<li>web服务器软件：接收用户的请求，处理请求，做出响应。<ul>
<li>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目</li>
<li>web容器</li>
<li>常见的java相关的web服务器软件：<ul>
<li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li>
<li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</li>
</ul>
<ul>
<li><p>Tomcat：web服务器软件</p>
<ol>
<li><p>下载：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p>
</li>
<li><p>安装：解压压缩包即可。</p>
<ul>
<li>注意：安装目录建议不要有中文和空格</li>
</ul>
</li>
<li><p>卸载：删除目录就行了</p>
</li>
<li><p>启动：</p>
<ul>
<li>bin/startup.bat ,双击运行该文件即可</li>
<li>访问：浏览器输入：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 回车访问自己<pre><code>           http://别人的ip:8080 回车访问别人</code></pre> 可能遇到的问题：<ol>
<li>黑窗口一闪而过：</li>
</ol>
<ul>
<li>原因： 没有正确配置JAVA_HOME环境变量</li>
<li>解决方案：正确配置JAVA_HOME环境变量</li>
</ul>
<ol start="2">
<li>启动报错：<ol>
<li>暴力：找到占用的端口号，并且找到对应的进程，杀死该进程<ul>
<li>netstat -ano</li>
</ul>
</li>
<li>温柔：修改自身的端口号<ul>
<li>conf/server.xml</li>
<li>&lt;Connector port=”8888” protocol=”HTTP/1.1”<br>connectionTimeout=”20000”redirectPort=”8445” /&gt;</li>
<li>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</li>
<li>好处：在访问时，就不用输入端口号</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="5">
<li><p>关闭：</p>
<ol start="6">
<li><p>正常关闭：</p>
<ul>
<li>bin/shutdown.bat</li>
<li>ctrl+c</li>
</ul>
</li>
<li><p>强制关闭：</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>点击启动窗口的×</li>
</ul>
<ol start="6">
<li><p>配置:</p>
<ul>
<li><p>部署项目的方式：</p>
<ol>
<li><p>直接将项目放到webapps目录下即可。</p>
<ul>
<li><p>/hello：项目的访问路径–&gt;虚拟目录</p>
</li>
<li><p>简化部署：将项目打成一个war包，再将war包放置到webapps目录下。</p>
</li>
<li><p>war包会自动解压缩</p>
</li>
</ul>
</li>
<li><p>配置conf/server.xml文件</p>
<ul>
<li>在<host>标签体中配置<context docbase="D:\hello" path="/hehe"></context></host></li>
<li>docBase:项目存放的路径</li>
<li>path：虚拟目录</li>
</ul>
</li>
<li><p>在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写</p>
  <context docbase="D:\hello">
  - 虚拟目录：xml文件的名称






</context></li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>静态项目和动态项目：<ul>
<li>目录结构<ul>
<li>java动态项目的目录结构：<ul>
<li>项目的根目录<ul>
<li>WEB-INF目录：<ul>
<li>web.xml：web项目的核心配置文件</li>
<li>classes目录：放置字节码文件的目录</li>
<li>lib目录：放置依赖的jar包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</li>
</ul>
<h2 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h2><ul>
<li>概念：运行在服务器端的小程序<ul>
<li>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</li>
<li>将来我们自定义一个类，实现Servlet接口，复写方法。</li>
</ul>
</li>
</ul>
<ul>
<li><p>快速入门：</p>
<ol>
<li><p>创建JavaEE项目</p>
</li>
<li><p>定义一个类，实现Servlet接口</p>
<ul>
<li>public class ServletDemo1 implements Servlet</li>
</ul>
</li>
<li><p>实现接口中的抽象方法</p>
</li>
<li><p>配置Servlet </p>
<p>在web.xml中配置：</p>
<blockquote>
 <!--配置Servlet -->
   <servlet>
       <servlet-name>demo1</servlet-name>
       <servlet-class>cn.itcast.web.servlet.ServletDemo1</servlet-class>
   </servlet> <servlet-mapping>
       <servlet-name>demo1</servlet-name>
       <url-pattern>/demo1</url-pattern>
   </servlet-mapping>
</blockquote>
</li>
</ol>
</li>
<li><p>执行原理：</p>
<ol>
<li><p>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</p>
</li>
<li><p>查找web.xml文件，是否有对应的<url-pattern>标签体内容。</url-pattern></p>
</li>
<li><p>如果有，则在找到对应的<servlet-class>全类名</servlet-class></p>
</li>
<li><p>tomcat会将字节码文件加载进内存，并且创建其对象</p>
</li>
<li><p>调用其方法</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Servlet中的生命周期方法：</p>
<ol>
<li><p>被创建：执行init方法，只执行一次</p>
<blockquote>
<p>Servlet什么时候被创建？</p>
<p>默认情况下，第一次被访问时，Servlet被创建</p>
<p>可以配置执行Servlet的创建时机。</p>
<p>在<servlet>标签下配置</servlet></p>
<ol>
<li><p>第一次被访问时，创建</p>
<p><load-on-startup>的值为负数</load-on-startup></p>
</li>
<li><p>在服务器启动时，创建<br><load-on-startup>的值为0或正整数</load-on-startup></p>
</li>
</ol>
</blockquote>
<p>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的</p>
</li>
</ol>
<blockquote>
<p>多个用户同时访问时，可能存在线程安全问题。</p>
<p>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</p>
</blockquote>
<ol start="2">
<li><p>提供服务：执行service方法，执行多次</p>
<ul>
<li>每次访问Servlet时，Service方法都会被调用一次。</li>
</ul>
</li>
<li><p>被销毁：执行destroy方法，只执行一次</p>
<ul>
<li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li>
<li>只有服务器正常关闭时，才会执行destroy方法。</li>
<li>destroy方法在Servlet被销毁之前执行，一般用于释放资源</li>
</ul>
</li>
</ol>
</li>
<li><p>Servlet3.0：</p>
<p>好处：</p>
<ul>
<li>支持注解配置。可以不需要web.xml了。</li>
</ul>
<p>步骤：</p>
<ul>
<li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li>
<li>定义一个类，实现Servlet接口</li>
<li>复写方法<ul>
<li>在类上使用@WebServlet注解，进行配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">* @WebServlet("资源路径")</code></pre>
<pre><code class="java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface WebServlet {
    String name() default "";//相当于&lt;Servlet-name&gt;

    String[] value() default {};//代表urlPatterns()属性配置

    String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;

    int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;

    WebInitParam[] initParams() default {};

    boolean asyncSupported() default false;

    String smallIcon() default "";

    String largeIcon() default "";

    String description() default "";

    String displayName() default "";
}</code></pre>
<h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><ol>
<li>IDEA会为每一个tomcat部署的项目单独建立一份配置文件</li>
</ol>
<ul>
<li><p>查看控制台的log：Using CATALINA_BASE:   “C:\Users\fqy.IntelliJIdea2018.1\system\tomcat_itcast”</p>
<ol start="2">
<li><p>工作空间项目    和     tomcat部署的web项目</p>
<ul>
<li>tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问。</li>
</ul>
</li>
<li><p>断点调试：使用”小虫子”启动 dubug 启动</p>
</li>
</ol>
</li>
</ul>
<h2 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h2><p>Servlet – 接口<br>​      |<br>​GenericServlet – 抽象类<br>​      |<br>​HttpServlet  – 抽象类</p>
<ul>
<li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p>
<ul>
<li>将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可</li>
</ul>
</li>
<li><p>HttpServlet：对http协议的一种封装，简化操作</p>
<ul>
<li>定义类继承HttpServlet</li>
<li>复写doGet/doPost方法</li>
</ul>
</li>
</ul>
<p><strong>Servlet相关配置</strong></p>
<ol>
<li>urlpartten:Servlet访问路径<ol>
<li>一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”})</li>
<li>路径定义规则：<ol>
<li>/xxx：路径匹配</li>
<li>/xxx/xxx:多层路径，目录结构</li>
<li>*.do：扩展名匹配</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><ul>
<li><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p>
<ul>
<li><p>传输协议：定义了 客户端和服务器端通信时，发送数据的格式</p>
</li>
<li><p>特点：</p>
<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号:80</li>
<li>基于请求/响应模型的:一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</li>
<li><p>历史版本：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h3><p>客户端发送给服务器的数据</p>
<ul>
<li><p>请求消息数据格式</p>
<ol>
<li>请求行<br>请求方式     请求url         请求协议/版本<br>GET             /login.html   HTTP/1.1</li>
</ol>
<ul>
<li><p>请求方式：</p>
<ul>
<li><p>HTTP协议有7种请求方式，常用的有2种</p>
<ul>
<li><p>GET：</p>
<ol>
<li><p>请求参数在请求行中，在url后。</p>
</li>
<li><p>请求的url长度有限制的</p>
</li>
<li><p>不太安全</p>
</li>
</ol>
</li>
<li><p>POST：</p>
<ol>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制的</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>请求头：客户端浏览器告诉服务器一些信息<br>请求头名称: 请求头值</p>
<ul>
<li><p>常见的请求头：</p>
<ol>
<li><p>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息</p>
<ul>
<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>Referer：<a href="http://localhost/login.html" target="_blank" rel="noopener">http://localhost/login.html</a><br> 告诉服务器，我(当前请求)从哪里来？<br> 作用：<ul>
<li>防盗链</li>
<li>统计工作：</li>
</ul>
</li>
</ol>
</li>
<li><p>请求空行<br>空行，就是用于分割POST请求的请求头，和请求体的。</p>
</li>
<li><p>请求体(正文)：</p>
</li>
</ol>
<ul>
<li><p>封装POST请求消息的请求参数的</p>
</li>
<li><p>字符串格式：</p>
<pre><code> POST /login.html HTTP/1.1
 Host: localhost
 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
 Accept-Encoding: gzip, deflate
 Referer: http://localhost/login.html
 Connection: keep-alive
 Upgrade-Insecure-Requests: 1

 username=zhangsan </code></pre></li>
</ul>
</li>
</ul>
<h3 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h3><p>服务器发送给客户端的消息</p>
<ul>
<li><p>响应消息数据格式</p>
<ol>
<li><p>响应行</p>
<ul>
<li><p>组成：协议/版本 响应状态码   状态码描述</p>
</li>
<li><p>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态</p>
<ul>
<li><p>状态码都是3位数字</p>
</li>
<li><p>分类</p>
<ol>
<li><p>1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码</p>
</li>
<li><p>2xx：成功。代表：200</p>
</li>
<li><p>3xx：302（重定向），304（访问缓存）</p>
</li>
<li><p>4xx：客户端错误。</p>
<p>代表：</p>
<ul>
<li>404（请求路径没有对应的资源）</li>
<li>405（请求方式没有对应的doXXX方法）</li>
</ul>
</li>
<li><p>5xx：服务端错误。代表：500（服务器内部出现错误）</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>响应头：传输的数据</p>
<ol>
<li>格式：头名称：值</li>
<li>常见的响应头：<ol>
<li>Conteent-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition:服务器告诉客户端以什么格式打开响应体数据<ol>
<li>in-line:默认值，在当前界面内打开</li>
<li>attachment;filename=xxx：以附件形式打开响应体。文件下载</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>响应空行</p>
</li>
<li><p>响应体</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>响应字符串格式</p>
<pre><code>HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=UTF-8
Content-Length: 90
Date: Tue, 05 May 2020 00:51:55 GMT

&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  WDNMD
  &lt;/body&gt;
&lt;/html&gt;</code></pre></li>
</ul>
<h2 id="Requet"><a href="#Requet" class="headerlink" title="Requet"></a>Requet</h2><ol>
<li><p>request对象和response对象的原理</p>
<ul>
<li><p>request和response对象是由服务器创建的。我们来使用它们</p>
</li>
<li><p>request对象是来获取请求消息，response对象是来设置响应消息</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>request对象继承体系结构： </p>
<pre><code>ServletRequest  -- 接口
       | 继承
HttpServletRequest -- 接口
       | 实现</code></pre><p>org.apache.catalina.connector.RequestFacade 类(tomcat)</p>
</li>
<li><p>request功能：</p>
<ol>
<li>获取请求消息数据</li>
<li>获取请求行数据</li>
</ol>
</li>
</ol>
<pre><code class="java">* GET /day14/demo1?name=zhangsan HTTP/1.1
* 方法：
 1. 获取请求方式 ：GET
  * String getMethod()  
 2. (*)获取虚拟目录：/day14
  * String getContextPath()
 3. 获取Servlet路径: /demo1
  * String getServletPath()
 4. 获取get方式请求参数：name=zhangsan
  * String getQueryString()
 5. (*)获取请求URI：/day14/demo1
  * String getRequestURI():  /day14/demo1
  * StringBuffer getRequestURL()  :http://localhost/day14/demo1

  * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国
  * URI：统一资源标识符 : /day14/demo1     共和国

 6. 获取协议及版本：HTTP/1.1
  * String getProtocol()

 7. 获取客户机的IP地址：
  * String getRemoteAddr()</code></pre>
<pre><code>3. 获取请求头数据
* 方法：
 * (*)String getHeader(String name):通过请求头的名称获取请求头的值
 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称

4. 获取请求体数据:
* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
* 步骤：
 1. 获取流对象
  *  BufferedReader getReader()：获取字符输入流，只能操作字符数据
  *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
   * 在文件上传知识点后讲解

 2. 再从流对象中拿数据</code></pre><ol start="2">
<li>其他功能：</li>
</ol>
<ul>
<li>获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数<br>​    1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123<br>​    2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game<br>​    3. Enumeration<string> getParameterNames():获取所有请求的参数名称<br>​    4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合</string></li>
<li>中文乱码问题：<br>​get方式：tomcat 8 已经将get方式乱码问题解决了<br>​post方式：会乱码<br>​      * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”);</li>
</ul>
<p>​     </p>
<ul>
<li><p>请求转发：一种在服务器内部的资源跳转方式<br>​    1. 步骤</p>
<ul>
<li><p>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</p>
</li>
<li><p>使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) </p>
</li>
</ul>
<p>​    2. 特点：<br>​       1. 浏览器地址栏路径不发生变化<br>​       2. 只能转发到当前服务器内部资源中。<br>​       3. 转发是一次请求</p>
</li>
</ul>
<ol start="3">
<li><p>共享数据：<br>域对象：一个有作用范围的对象，可以在范围内共享数据<br>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据<br>方法：</p>
</li>
<li><p>void setAttribute(String name,Object obj):存储数据</p>
</li>
<li><p>Object getAttitude(String name):通过键获取值</p>
</li>
<li><p>void removeAttribute(String name):通过键移除键值对</p>
</li>
<li><p>获取ServletContext：</p>
<ul>
<li>ServletContext getServletContext()</li>
</ul>
</li>
</ol>
<h2 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h2><ul>
<li>用户登录案例需求：<br> 1.编写login.html登录页面<br>username &amp; password 两个输入框<br> 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表<br> 3.使用JdbcTemplate技术封装JDBC<br> 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您<br> 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误</li>
</ul>
<ul>
<li><p>分析</p>
</li>
<li><p>开发步骤</p>
<ol>
<li><p>创建项目，导入html页面，配置文件，jar包</p>
</li>
<li><p>创建数据库环境<br>CREATE DATABASE day14;<br>USE day14;<br>CREATE TABLE USER(</p>
<p>id INT PRIMARY KEY AUTO_INCREMENT,<br>username VARCHAR(32) UNIQUE NOT NULL,<br>PASSWORD VARCHAR(32) NOT NULL<br>);</p>
</li>
<li><p>创建包cn.itcast.domain,创建类User<br>package cn.itcast.domain;<br>/**</p>
<ul>
<li><p>用户的实体类</p>
</li>
<li><p>/<br>public class User {</p>
<p>private int id;<br>private String username;<br>private String password;</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​       public int getId() {<br>​           return id;<br>​       }<br>​<br>​       public void setId(int id) {<br>​           this.id = id;<br>​       }<br>​<br>​       public String getUsername() {<br>​           return username;<br>​       }<br>​<br>​       public void setUsername(String username) {<br>​           this.username = username;<br>​       }<br>​<br>​       public String getPassword() {<br>​           return password;<br>​       }</p>
<pre><code>   public void setPassword(String password) {
       this.password = password;
   }

   @Override
   public String toString() {
       return "User{" +
               "id=" + id +
               ", username='" + username + '\'' +
               ", password='" + password + '\'' +
               '}';
   }</code></pre><p>   }<br>  4. 创建包cn.itcast.util,编写工具类JDBCUtils<br>      package cn.itcast.util;</p>
<p>   import com.alibaba.druid.pool.DruidDataSourceFactory;</p>
<p>   import javax.sql.DataSource;<br>   import javax.xml.crypto.Data;<br>   import java.io.IOException;<br>   import java.io.InputStream;<br>   import java.sql.Connection;<br>   import java.sql.SQLException;<br>   import java.util.Properties;</p>
<p>   /**<br>    * JDBC工具类 使用Durid连接池<br>    */<br>   public class JDBCUtils {</p>
<pre><code>   private static DataSource ds ;

   static {

       try {
           //1.加载配置文件
           Properties pro = new Properties();
           //使用ClassLoader加载配置文件，获取字节输入流
           InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");
           pro.load(is);

           //2.初始化连接池对象
           ds = DruidDataSourceFactory.createDataSource(pro);

       } catch (IOException e) {
           e.printStackTrace();
       } catch (Exception e) {
           e.printStackTrace();
       }
   }

   /**
    * 获取连接池对象
    */
   public static DataSource getDataSource(){
       return ds;
   }</code></pre><p>​       /**<br>​        * 获取连接Connection对象<br>​        <em>/<br>​       public static Connection getConnection() throws SQLException {<br>​           return  ds.getConnection();<br>​       }<br>​   }<br>​  5. 创建包cn.itcast.dao,创建类UserDao,提供login方法<br>​<br>​   package cn.itcast.dao;<br>​<br>​   import cn.itcast.domain.User;<br>​   import cn.itcast.util.JDBCUtils;<br>​   import org.springframework.dao.DataAccessException;<br>​   import org.springframework.jdbc.core.BeanPropertyRowMapper;<br>​   import org.springframework.jdbc.core.JdbcTemplate;<br>​<br>​   /*</em><br>​    * 操作数据库中User表的类<br>​    */<br>​   public class UserDao {<br>​<br>​       //声明JDBCTemplate对象共用<br>​       private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());</p>
<pre><code>   /**
    * 登录方法
    * @param loginUser 只有用户名和密码
    * @return user包含用户全部数据,没有查询到，返回null
    */
   public User login(User loginUser){
       try {
           //1.编写sql
           String sql = "select * from user where username = ? and password = ?";
           //2.调用query方法
           User user = template.queryForObject(sql,
                   new BeanPropertyRowMapper&lt;User&gt;(User.class),
                   loginUser.getUsername(), loginUser.getPassword());</code></pre><p>​               return user;<br>​           } catch (DataAccessException e) {<br>​               e.printStackTrace();//记录日志<br>​               return null;<br>​           }<br>​       }<br>​   }<br>​<br>​  6. 编写cn.itcast.web.servlet.LoginServlet类<br>​   package cn.itcast.web.servlet;<br>​<br>​   import cn.itcast.dao.UserDao;<br>​   import cn.itcast.domain.User;<br>​<br>​   import javax.servlet.ServletException;<br>​   import javax.servlet.annotation.WebServlet;<br>​   import javax.servlet.http.HttpServlet;<br>​   import javax.servlet.http.HttpServletRequest;<br>​   import javax.servlet.http.HttpServletResponse;<br>​   import java.io.IOException;</p>
<p>   @WebServlet(“/loginServlet”)<br>​   public class LoginServlet extends HttpServlet {</p>
<p>​       @Override<br>​       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>​           //1.设置编码<br>​           req.setCharacterEncoding(“utf-8”);<br>​           //2.获取请求参数<br>​           String username = req.getParameter(“username”);<br>​           String password = req.getParameter(“password”);<br>​           //3.封装user对象<br>​           User loginUser = new User();<br>​           loginUser.setUsername(username);<br>​           loginUser.setPassword(password);<br>​<br>​           //4.调用UserDao的login方法<br>​           UserDao dao = new UserDao();<br>​           User user = dao.login(loginUser);<br>​<br>​           //5.判断user<br>​           if(user == null){<br>​               //登录失败<br>​               req.getRequestDispatcher(“/failServlet”).forward(req,resp);<br>​           }else{<br>​               //登录成功<br>​               //存储数据<br>​               req.setAttribute(“user”,user);<br>​               //转发<br>​               req.getRequestDispatcher(“/successServlet”).forward(req,resp);<br>​           }<br>​<br>​       }<br>​<br>​       @Override<br>​       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>​           this.doGet(req,resp);<br>​       }<br>   }</p>
<ol start="7">
<li><p>编写FailServlet和SuccessServlet类<br> @WebServlet(“/successServlet”)<br> public class SuccessServlet extends HttpServlet {<br>  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</p>
<pre><code>  //获取request域中共享的user对象
  User user = (User) request.getAttribute("user");

  if(user != null){
      //给页面写一句话

      //设置编码
      response.setContentType("text/html;charset=utf-8");
      //输出
      response.getWriter().write("登录成功！"+user.getUsername()+",欢迎您");
  }</code></pre></li>
</ol>
<p>​       }  </p>
<p>   @WebServlet(“/failServlet”)<br>   public class FailServlet extends HttpServlet {<br>       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>           //给页面写一句话</p>
<pre><code>       //设置编码
       response.setContentType("text/html;charset=utf-8");
       //输出
       response.getWriter().write("登录失败，用户名或密码错误");

   }

   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
       this.doPost(request,response);
   }</code></pre><p>   }</p>
<ol start="8">
<li><p>login.html中form表单的action路径的写法</p>
<ul>
<li>虚拟目录+Servlet的资源路径</li>
</ul>
</li>
<li><p>BeanUtils工具类，简化数据封装</p>
<ul>
<li>用于封装JavaBean的</li>
</ul>
<ol>
<li>JavaBean：标准的Java类<ol>
<li>要求：<ol>
<li>类必须被public修饰</li>
<li>必须提供空参的构造器</li>
<li>成员变量必须使用private修饰</li>
<li>提供公共setter和getter方法</li>
</ol>
</li>
<li>功能：封装数据</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>概念：</p>
<p>成员变量：<br>属性：setter和getter方法截取后的产物<br>例如：getUsername() –&gt; Username–&gt; username</p>
</li>
</ol>
<ol start="3">
<li>方法：<ol>
<li>setProperty()</li>
<li>getProperty()</li>
<li>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</li>
</ol>
</li>
</ol>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><ul>
<li><p>功能：设置响应消息</p>
<ol>
<li><p>设置响应行</p>
<ol>
<li><p>格式：HTTP/1.1 200 ok</p>
</li>
<li><p>设置状态码： setStatus（int sc）</p>
</li>
<li><p>设置响应头：setHeader（String name,String value）</p>
</li>
<li><p>设置响应体</p>
<ol>
<li><p>获取输出流：</p>
<ol>
<li>字符输出流：PrintWriter getWriter（）</li>
<li>字节输出流：ServletOutputStream（）</li>
</ol>
</li>
<li><p>使用输出流，将数据输出到客户端浏览器</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>案例</p>
<ol>
<li><p><strong>完成重定向</strong></p>
<p>重定向：资源跳转的方式</p>
<pre><code class="java">//访问/responseDemo1,会自动自动跳转到/responseDemo2资源
            //1.设置状态码为302
             response.setStatus(302);
             //2.设置响应头location
             response.setHeader("location","/day15/responseDemo2");

       //简单的重定向方法
        response.sendRedirect("/day15/responseDemo2");</code></pre>
<ul>
<li>重定向的特点：</li>
</ul>
<ol>
<li>地址栏发生变化</li>
<li>重定向可以访问其他站点（服务器）的资源</li>
<li>重定向是两次请求，不能使用request对象来共享数据 </li>
</ol>
<ul>
<li>转发的特点：</li>
</ul>
<ol>
<li>转发地址栏路径不变</li>
<li>转发只能访问当前服务器下的资源</li>
<li>转发是一次请求，意味着request对象来共享数据<ul>
<li>forward 和redirect的区别</li>
</ul>
</li>
</ol>
<ul>
<li><p>路径写法</p>
<ul>
<li><p>路径分类</p>
<ol>
<li><p>相对路径：通过相对路径不能确定唯一资源</p>
<p>如：./index.html</p>
<p>不以/开头，以.开头路径</p>
<ul>
<li>规则：找到当前资源和目标资源之间的相对路径<ul>
<li>./ : 当前路径</li>
<li>../: 后退一级目录</li>
</ul>
</li>
</ul>
</li>
<li><p>绝对路径：通过绝对路径可以确定唯一资源</p>
<ul>
<li>如：<a href="http://localhost/day15/responseDemo2" target="_blank" rel="noopener">http://localhost/day15/responseDemo2</a></li>
<li>以/开头的路径</li>
<li>规则：判断定义的路径是给谁用的？判断请求是从哪儿发出<ul>
<li>给客户端浏览器使用：需要加虚拟目录 ( 项目的访问路径 ) <ul>
<li>建议虚拟目录动态获取：request.getContextPath()</li>
<li><code>&lt;a&gt;</code> <code>&lt;form&gt;</code>  <code>重定向</code></li>
</ul>
</li>
<li>给服务器使用，不需要加虚拟目录<ul>
<li>转发路径</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器输出字符数据到浏览器</strong></p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>获取字符输入流</p>
<p><code>PrintWriter pw =response.getWriter();</code></p>
</li>
<li><p>输出数据</p>
<p><code>pw.write("你好 response");</code></p>
</li>
</ol>
</li>
<li><p>注意：乱码问题</p>
<ul>
<li><code>PrintWriter pw =response.getWriter();</code>获取的流默认编码为 ISO-8859-1</li>
<li>设置该流的默认编码</li>
<li>告诉浏览器响应体使用的编码</li>
<li>简单的形式<code>response.setContentType("text/html;charset=utf-8");</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p><strong>服务器输出字节数据到浏览器</strong></p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>获取字节输入流</p>
<p><code>ServletOutputStream sos=response.getOutputStream();</code></p>
</li>
<li><p>输出数据</p>
<p><code>sos.write("你好".getBytes("utf-8"));</code></p>
</li>
</ol>
</li>
<li><p>注意：乱码问题</p>
<p><code>response.setContentType("text/html;charset=utf-8");</code></p>
</li>
</ul>
</li>
<li><p><strong>验证码</strong></p>
<ol>
<li>本质：图片</li>
<li>目的：防止恶意表单注册</li>
</ol>
<pre><code class="java">        int width=100;
        int height=50;
        //1.创建一对象，在内存中图片（验证码对象）
        BufferedImage image= new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);

        //2.美化图片
        //2.1填充背景色
        Graphics g=image.getGraphics();//画笔对象
        g.setColor(Color.PINK);//设置画笔颜色
        g.fillRect(0,0,width,height);//填充
        //g.draw 画
        //2.2画边框
        g.setColor(Color.BLUE);
        g.drawRect(0,0,width-1,height-1);

        String str="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        //生成随机角标
        Random ran=new Random();

        for (int i = 0; i &lt;=4 ; i++) {
            int index=ran.nextInt(str.length());
            //获取字符
            char ch=str.charAt(index);//随机字符
            //2.3写验证码
            g.drawString(ch+"",width/5*i,height/2);//因为要写字符串 所以ch+""拼制成字符串
        }
        //2.4画干扰线
        g.setColor(Color.GREEN);
        //随机生成坐标点
        for (int i = 0; i &lt; 10; i++) {
            int x1=ran.nextInt(width);
            int x2=ran.nextInt(width);
            int y1=ran.nextInt(height);
            int y2=ran.nextInt(height);
            g.drawLine(x1,y1,x2,y2);
        }
        //3.将图片输出到页面展示
        ImageIO.write(image,"jpg",response.getOutputStream());</code></pre>
</li>
</ol>
<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><ol>
<li><p>概念：代表整个web应用，可以和程序的容器（服务器）来通信</p>
</li>
<li><p>获取：</p>
<ol>
<li><p>通过request对象获取</p>
<p><code>request.getServletContext();</code></p>
</li>
<li><p>通过HttpServlet获取</p>
<p><code>this.getServletContext();</code></p>
</li>
</ol>
</li>
<li><p>功能：</p>
<ol>
<li><p>获取MIME类型</p>
<blockquote>
<p>MIME类型: 在互联网通信过程中定义的一种文件数据类型</p>
<p>格式： 大类型/小类型      text/html        image/jpeg</p>
</blockquote>
<ul>
<li>获取：<code>String getMimeType(String file)</code></li>
</ul>
</li>
<li><p>域对象：共享数据</p>
<ol>
<li><code>setAttribute(String name,Object value)</code></li>
<li><code>getAttribute(String name)</code></li>
<li><code>removeAttribute(String name)</code></li>
</ol>
<ul>
<li>ServletContext对象范围：所有用户所有请求的数据</li>
</ul>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>获取文件的真实（服务器）路径</p>
<ol>
<li>方法：<code>String getRealPath(String path)</code></li>
</ol>
<blockquote>
<p>在 /web文件夹下   直接<code>getRealPath("/b.txt");</code></p>
<p>在 /web/WEB-INF文件夹下 <code>getRealPath("/WEB-INF/c.txt");</code></p>
<p>在 /src文件夹下 <code>getRealPath("/WEN-INf/classes/a.txt")</code></p>
</blockquote>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVAE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的命令行指令</title>
    <url>/lzfangwen.github.io/2020/07/09/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<a id="more"></a>

<p><code>dir</code>     列出当前目录下的文件以及文件夹</p>
<p><code>cd 文件夹名</code>    进入指定目录</p>
<p><code>md 文件夹名</code>    创建目录</p>
<p><code>cd..</code>    返回上层文件夹</p>
<p><code>cd/</code>    退回到根目录</p>
<p><code>del 文件名</code>    删除指定文件</p>
<p><code>rd 文件夹名</code>    删除目录</p>
<p><code>ipconfig</code>    查看本机ip地址</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>JDBC笔记</title>
    <url>/lzfangwen.github.io/2020/07/03/JDBC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>概念：Java DateBase Connectivity   Java数据库连接</p>
<p><strong>本质</strong>：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<a id="more"></a>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>导入驱动jar包<ol>
<li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li>
<li>右键–&gt;Add As Library</li>
</ol>
</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行sql语句的对象 Statement</li>
<li>执行sql，接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
<pre><code class="java">//代码实现：
          //1. 导入驱动jar包
        //2.注册驱动
        Class.forName("com.mysql.jdbc.Driver");
        //3.获取数据库连接对象
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root");
        //4.定义sql语句
        String sql = "update account set balance = 500 where id = 1";
        //5.获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();
        //6.执行sql
        int count = stmt.executeUpdate(sql);
        //7.处理结果
        System.out.println(count);
        //8.释放资源
        stmt.close();
        conn.close();</code></pre>
<h2 id="详解各个对象"><a href="#详解各个对象" class="headerlink" title="详解各个对象"></a>详解各个对象</h2><h3 id="DriverManager：驱动管理对象"><a href="#DriverManager：驱动管理对象" class="headerlink" title="DriverManager：驱动管理对象"></a><strong>DriverManager：驱动管理对象</strong></h3><ul>
<li><p>功能：</p>
<ol>
<li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar<br> <code>static void registerDriver(Driver driver)</code> :注册与给定的驱动程序 DriverManager 。<br> 写代码使用：  <code>Class.forName("com.mysql.jdbc.Driver");</code><br> 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</p>
<pre><code class="java">  static {
         try {
             java.sql.DriverManager.registerDriver(new Driver());
         } catch (SQLException E) {
             throw new RuntimeException("Can't register driver!");
 }
     }</code></pre>
<p> 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p>
</li>
<li><p>获取数据库连接：</p>
<ul>
<li>方法：<code>static Connection getConnection(String url, String user, String password)</code> </li>
<li>参数：<ul>
<li>url：指定连接的路径<ul>
<li>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li>
<li>例子：jdbc:mysql://localhost:3306/db3</li>
<li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li>
</ul>
</li>
<li>user：用户名</li>
<li>password：密码 </li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Connection：数据库连接对象"><a href="#Connection：数据库连接对象" class="headerlink" title="Connection：数据库连接对象"></a><strong>Connection：数据库连接对象</strong></h3><ol>
<li>功能：<pre><code> 1. 获取执行sql 的对象
     * `Statement createStatement()`
 * `PreparedStatement prepareStatement(String sql)`  </code></pre><ol start="2">
<li>管理事务：<ul>
<li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：<code>commit()</code> </li>
<li>回滚事务：<code>rollback()</code> </li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Statement：执行sql的对象"><a href="#Statement：执行sql的对象" class="headerlink" title="Statement：执行sql的对象"></a><strong>Statement：执行sql的对象</strong></h3><ol>
<li><p>执行sql</p>
<pre><code> 1. `boolean execute(String sql)` ：可以执行任意的sql 了解 

 2. `int executeUpdate(String sql)` ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句
     * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
 3. `ResultSet executeQuery(String sql)`  ：执行DQL（select)语句</code></pre><ol start="2">
<li><p>练习：</p>
<ol>
<li>account表 添加一条记录</li>
</ol>
</li>
<li><p>account表 修改记录</p>
<ol start="3">
<li><p>account表 删除一条记录</p>
<p>代码：</p>
</li>
</ol>
<pre><code class="java">Statement stmt = null;
Connection conn = null;
try {
    //1. 注册驱动
    Class.forName("com.mysql.jdbc.Driver");
    //2. 定义sql
    String sql = "insert into account values(null,'王五',3000)";
    //3.获取Connection对象
    conn = DriverManager.getConnection("jdbc:mysql:///db3", "root", "root");
    //4.获取执行sql的对象 Statement
    stmt = conn.createStatement();
    //5.执行sql
    int count = stmt.executeUpdate(sql);//影响的行数
    //6.处理结果
    System.out.println(count);
    if(count &gt; 0){
        System.out.println("添加成功！");
    }else{
     System.out.println("添加失败！");
    }

} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
}finally {
    //stmt.close();
    //7. 释放资源
    //避免空指针异常
    if(stmt != null){
        try {
            stmt.close();
        } catch (SQLException e) {
            e.printStackTrace();
     }
    }

    if(conn != null){
        try {
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p>标准写法：便于关闭</p>
<pre><code class="java">package cn.itcast.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

/**
* account表 添加一条记录 insert 语句
*/
public class JDBCDemo2 {
 public static void main(String[] args) {
     Statement stmt = null;
     Connection conn = null;
     try {
         //1. 注册驱动
         Class.forName("com.mysql.jdbc.Driver");
         //2. 定义sql
         String sql = "insert into account values(null,'王五',3000)";
         //3.获取Connection对象
         conn = DriverManager.getConnection("jdbc:mysql:///db3", "root", "root");
         //4.获取执行sql的对象 Statement
         stmt = conn.createStatement();
         //5.执行sql
         int count = stmt.executeUpdate(sql);//影响的行数
         //6.处理结果
         System.out.println(count);
         if(count &gt; 0){
             System.out.println("添加成功！");
         }else{
             System.out.println("添加失败！");
         }

     } catch (ClassNotFoundException e) {
         e.printStackTrace();
     } catch (SQLException e) {
         e.printStackTrace();
     }finally {
         //stmt.close();
         //7. 释放资源
         //避免空指针异常
         if(stmt != null){
             try {
                 stmt.close();
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }

         if(conn != null){
             try {
                 conn.close();
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }
     }
 }
}</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="ResultSet：结果集对象-封装查询结果"><a href="#ResultSet：结果集对象-封装查询结果" class="headerlink" title="ResultSet：结果集对象,封装查询结果"></a>ResultSet：结果集对象,封装查询结果</h3><ul>
<li><p><code>boolean next():</code> 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p>
<ul>
<li><p>getXxx(参数):获取数据</p>
<ul>
<li>Xxx：代表数据类型   如： int getInt() ,    String getString()</li>
<li>参数：<ol>
<li>int：代表列的编号,从1开始   如： getString(1)</li>
<li>String：代表列名称。 如： getDouble(“balance”)</li>
</ol>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>使用步骤：<ol>
<li>游标向下移动一行</li>
<li>判断是否有数据</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>获取数据</p>
<pre><code class="java">//循环判断游标是否是最后一行末尾。
while(rs.next()){
//获取数据
int id = rs.getInt(1);
String name = rs.getString("name");
double balance = rs.getDouble(3);
System.out.println(id + "---" + name + "---" + balance);
}</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>* 练习：
    * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
        1. 定义Emp类
        2. 定义方法 public List&lt;Emp&gt; findAll(){}
        3. 实现方法 select * from emp;</code></pre><h2 id="JDBC工具类"><a href="#JDBC工具类" class="headerlink" title="JDBC工具类"></a>JDBC工具类</h2><ul>
<li><p>目的：简化书写</p>
</li>
<li><p>分析：</p>
<ol>
<li><p>注册驱动也抽取</p>
</li>
<li><p>抽取一个方法获取连接对象</p>
<ul>
<li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li>
<li>解决：配置文件<br>jdbc.properties<pre><code>url=
user=
password=</code></pre></li>
</ul>
<ol start="3">
<li>抽取一个方法释放资源</li>
</ol>
</li>
</ol>
</li>
<li><p>代码实现：</p>
</li>
</ul>
<pre><code class="java">package cn.itcast.util;

import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.sql.*;
import java.util.Properties;

/**
 * JDBC工具类
 */
public class JDBCUtils {
    private static String url;
    private static String user;
    private static String password;
    private static String driver;
    /**
     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块
     */
    static{
        //读取资源文件，获取值。

        try {
            //1. 创建Properties集合类。
            Properties pro = new Properties();

            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器
            ClassLoader classLoader = JDBCUtils.class.getClassLoader();
            URL res  = classLoader.getResource("jdbc.properties");
            String path = res.getPath();
           // System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties
            //2. 加载文件
           // pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));
            pro.load(new FileReader(path));

            //3. 获取数据，赋值
            url = pro.getProperty("url");
            user = pro.getProperty("user");
            password = pro.getProperty("password");
            driver = pro.getProperty("driver");
            //4. 注册驱动
            Class.forName(driver);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }


    /**
     * 获取连接
     * @return 连接对象
     */
    public static Connection getConnection() throws SQLException {

        return DriverManager.getConnection(url, user, password);
    }

    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(Statement stmt,Connection conn){
        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * 释放资源
     * @param stmt
     * @param conn
     */
    public static void close(ResultSet rs,Statement stmt, Connection conn){
        if( rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if( conn != null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}
</code></pre>
<h2 id="JDBC事务管理"><a href="#JDBC事务管理" class="headerlink" title="JDBC事务管理"></a>JDBC事务管理</h2><ol>
<li>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li>
<li>操作：<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li>使用Connection对象来管理事务<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit() <ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback() <ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>代码实现</p>
<pre><code class="java">package cn.itcast.jdbc;

import cn.itcast.util.JDBCUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

/**
 * 事务操作
 */
public class JDBCDemo10 {


    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pstmt1 = null;
        PreparedStatement pstmt2 = null;

        try {
            //1.获取连接
            conn = JDBCUtils.getConnection();
            //开启事务
            conn.setAutoCommit(false);

            //2.定义sql
            //2.1 张三 - 500
            String sql1 = "update account set balance = balance - ? where id = ?";
            //2.2 李四 + 500
            String sql2 = "update account set balance = balance + ? where id = ?";
            //3.获取执行sql对象
            pstmt1 = conn.prepareStatement(sql1);
            pstmt2 = conn.prepareStatement(sql2);
            //4. 设置参数
            pstmt1.setDouble(1,500);
            pstmt1.setInt(2,1);

            pstmt2.setDouble(1,500);
            pstmt2.setInt(2,2);
            //5.执行sql
            pstmt1.executeUpdate();
            // 手动制造异常
            int i = 3/0;

            pstmt2.executeUpdate();
            //提交事务
            conn.commit();
        } catch (Exception e) {
            //事务回滚
            try {
                if(conn != null) {
                    conn.rollback();
                }
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            JDBCUtils.close(pstmt1,conn);
            JDBCUtils.close(pstmt2,null);
        }


    }

}
</code></pre>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><ol>
<li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p>
<pre><code> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</code></pre></li>
<li><p>好处：</p>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
</li>
<li><p>实现：</p>
<ol>
<li><p>标准接口：DataSource   javax.sql包下的</p>
<ol>
<li>方法：<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ul>
</li>
</ol>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ol>
<li>C3P0：数据库连接池技术</li>
<li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li>
</ol>
</li>
</ol>
</li>
<li><p>C3P0：数据库连接池技术</p>
<ul>
<li><p>步骤：</p>
<ol>
<li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p>
<ul>
<li>不要忘记导入数据库驱动jar包</li>
</ul>
</li>
<li><p>定义配置文件：</p>
<ul>
<li>名称： c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ul>
</li>
<li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p>
</li>
<li><p>获取连接： getConnection</p>
</li>
</ol>
</li>
<li><p>代码：<br>   //1.创建数据库连接池对象<br>  DataSource ds  = new ComboPooledDataSource();<br>  //2. 获取连接对象<br>  Connection conn = ds.getConnection();</p>
</li>
</ul>
</li>
</ol>
<pre><code class="java">public class C3P0Demo1 {
    public static void main(String[] args) throws SQLException {
        //1.创建数据库连接池对象
        DataSource ds  = new ComboPooledDataSource();
        //2. 获取连接对象
        Connection conn = ds.getConnection();

        //3. 打印
        System.out.println(conn);

    }
}</code></pre>
<ol start="5">
<li>Druid：数据库连接池实现技术，由阿里巴巴提供的<ol>
<li>步骤：<ol>
<li>导入jar包 druid-1.0.9.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂类来获取  DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="java">public class druidDemo1 {
    public static void main(String[] args) throws Exception {
        //1.导入jar包
        //2.定义配置文件
        //3.加载配置文件
        Properties pro = new Properties();
        InputStream is=druidDemo1.class.getClassLoader().getResourceAsStream("druid.properties");
        //通过当前类的名称.class获得字节码文件.etClassLoader().getResourceAsStream()获取资源路径 返回字节流
        pro.load(is);

        //4.获取连接池对象：通过工厂类来获取 DuridDataSourceFactory
        DataSource ds=DruidDataSourceFactory.createDataSource(pro);
        //5.获取连接
        Connection conn=ds.getConnection();
        System.out.println(conn);
    }
}</code></pre>
<ol start="2">
<li>定义工具类<pre><code> 1. 定义一个类 JDBCUtils
 2. 提供静态代码块加载配置文件，初始化连接池对象
 3. 提供方法
     1. 获取连接方法：通过数据库连接池获取连接
     2. 释放资源
     3. 获取连接池的方法</code></pre></li>
</ol>
<pre><code class="java">package cn.itcast.utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * Druid连接池的工具类
 */
public class JDBCUtils {

    //1.定义成员变量 DataSource
    private static DataSource ds ;

    static{
        try {
            //1.加载配置文件
            Properties pro = new Properties();
            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
            //2.获取DataSource
            ds = DruidDataSourceFactory.createDataSource(pro);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取连接
     */
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    /**
     * 释放资源
     */
    public static void close(Statement stmt,Connection conn){
       /* if(stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn != null){
            try {
                conn.close();//归还连接
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }*/

       close(null,stmt,conn);
    }


    public static void close(ResultSet rs , Statement stmt, Connection conn){


        if(rs != null){
            try {
                rs.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }


        if(stmt != null){
            try {
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn != null){
            try {
                conn.close();//归还连接
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 获取连接池方法
     */

    public static DataSource getDataSource(){
        return  ds;
    }

}
</code></pre>
<h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
<p>步骤：</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ul>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ul>
</li>
<li><p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li>update():执行DML语句。增、删、改语句</li>
<li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul>
<li>注意：这个方法查询的结果集长度只能是1</li>
</ul>
</li>
<li>queryForList():查询结果将结果集封装为list集合<ul>
<li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
</li>
<li>query():查询结果，将结果封装为JavaBean对象<ul>
<li>query的参数：RowMapper<ul>
<li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>
<li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li>
</ul>
</li>
</ul>
</li>
<li>queryForObject：查询结果，将结果封装为对象<ul>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
</li>
<li><p>练习：</p>
<ul>
<li>需求：<ol>
<li>修改1号数据的 salary 为 10000</li>
<li>添加一条记录</li>
<li>删除刚才添加的记录</li>
<li>查询id为1的记录，将其封装为Map集合</li>
<li>查询所有记录，将其封装为List</li>
<li>查询所有记录，将其封装为Emp对象的List集合</li>
<li>查询总记录数</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code class="java">package cn.itcast.jdbctemplate;

import cn.itcast.domain.Emp;
import cn.itcast.utils.JDBCUtils;
import org.junit.Test;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

public class JdbcTemplateDemo2 {

    //Junit单元测试，可以让方法独立执行


    //1. 获取JDBCTemplate对象
    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
    /**
     * 1. 修改1号数据的 salary 为 10000
     */
    @Test
    public void test1(){

        //2. 定义sql
        String sql = "update emp set salary = 10000 where id = 1001";
        //3. 执行sql
        int count = template.update(sql);
        System.out.println(count);
    }

    /**
     * 2. 添加一条记录
     */
    @Test
    public void test2(){
        String sql = "insert into emp(id,ename,dept_id) values(?,?,?)";
        int count = template.update(sql, 1015, "郭靖", 10);
        System.out.println(count);

    }

    /**
     * 3.删除刚才添加的记录
     */
    @Test
    public void test3(){
        String sql = "delete from emp where id = ?";
        int count = template.update(sql, 1015);
        System.out.println(count);
    }

    /**
     * 4.查询id为1001的记录，将其封装为Map集合
     * 注意：这个方法查询的结果集长度只能是1
     */
    @Test
    public void test4(){
        String sql = "select * from emp where id = ? or id = ?";
        Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);
        System.out.println(map);
        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}

    }

    /**
     * 5. 查询所有记录，将其封装为List
     */
    @Test
    public void test5(){
        String sql = "select * from emp";
        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);

        for (Map&lt;String, Object&gt; stringObjectMap : list) {
            System.out.println(stringObjectMap);
        }
    }

    /**
     * 6. 查询所有记录，将其封装为Emp对象的List集合
     */

    @Test
    public void test6(){
        String sql = "select * from emp";
        List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {

            @Override
            public Emp mapRow(ResultSet rs, int i) throws SQLException {
                Emp emp = new Emp();
                int id = rs.getInt("id");
                String ename = rs.getString("ename");
                int job_id = rs.getInt("job_id");
                int mgr = rs.getInt("mgr");
                Date joindate = rs.getDate("joindate");
                double salary = rs.getDouble("salary");
                double bonus = rs.getDouble("bonus");
                int dept_id = rs.getInt("dept_id");

                emp.setId(id);
                emp.setEname(ename);
                emp.setJob_id(job_id);
                emp.setMgr(mgr);
                emp.setJoindate(joindate);
                emp.setSalary(salary);
                emp.setBonus(bonus);
                emp.setDept_id(dept_id);

                return emp;
            }
        });


        for (Emp emp : list) {
            System.out.println(emp);
        }
    }

    /**
     * 6. 查询所有记录，将其封装为Emp对象的List集合
     */

    @Test
    public void test6_2(){
        String sql = "select * from emp";
        List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));
        for (Emp emp : list) {
            System.out.println(emp);
        }
    }

    /**
     * 7. 查询总记录数
     */

    @Test
    public void test7(){
        String sql = "select count(id) from emp";
        Long total = template.queryForObject(sql, Long.class);
        System.out.println(total);
    }

}
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JAVAEE</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记1</title>
    <url>/lzfangwen.github.io/2020/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200319155327527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>四个特性</strong></p>
<ul>
<li><strong>并发</strong><img src="https://img-blog.csdnimg.cn/20200319160437281.png" alt="在这里插入图片描述"></li>
<li><strong>共享</strong>即资源共享<img src="https://img-blog.csdnimg.cn/20200319160605652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>虚拟</strong><br><img src="https://img-blog.csdnimg.cn/20200319160708112.png" alt="在这里插入图片描述"></li>
<li><strong>异步</strong><br><img src="https://img-blog.csdnimg.cn/20200319160751700.png" alt="在这里插入图片描述"><br><strong>并发和共享互为存在条件<br>没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征</strong><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><img src="https://img-blog.csdnimg.cn/20200319192903977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="OS的运行机制和体系结构"><a href="#OS的运行机制和体系结构" class="headerlink" title="OS的运行机制和体系结构"></a>OS的运行机制和体系结构</h2><img src="https://img-blog.csdnimg.cn/20200319215155378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>※特权指令只能在核心态下执行</strong><br><strong>※内核程序只能在核心态下执行</strong><br><strong>※用户态-&gt;核心态 的切换通过 中断  来实现且是唯一途径</strong><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><img src="https://img-blog.csdnimg.cn/20200319215623593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><p><img src="https://img-blog.csdnimg.cn/2020031921574972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200319215823214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p><img src="https://img-blog.csdnimg.cn/20200319231430227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="https://img-blog.csdnimg.cn/20200320092825115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200320093028554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="https://www.bilibili.com/video/av70156862?t=15&amp;p=6" target="_blank" rel="noopener">来源 王道考研 操作系统</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>idea常用快捷键</title>
    <url>/lzfangwen.github.io/2020/05/17/idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://www.cnblogs.com/yanggb/p/10838388.html" target="_blank" rel="noopener">转自idea常用快捷键大全</a></p>
<p>Idea常用快捷键大全，拿小本本记下来，忘记了可以方便查找。</p>
<h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><p><kbd>Ctrl</kbd>+<kbd>Shift</kbd> + <kbd>Enter</kbd>，语句完成。</p>
<p><kbd>！</kbd>，否定完成，输入表达式时按 “！”键。</p>
<p><kbd>Ctrl</kbd>+<kbd>E</kbd>，最近的文件。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>E</kbd>，最近zh更改的文件。</p>
<p><kbd>Shift</kbd>+<kbd>Click</kbd>，可以关闭文件。</p>
<p><kbd>Ctrl</kbd>+<kbd>[ </kbd>OR <kbd>]</kbd>，可以跑到大括号的开头与结尾。</p>
<p><kbd>Ctrl</kbd>+<kbd>F12</kbd>，可以显示当前文件的结构。</p>
<p><kbd>Ctrl</kbd>+<kbd>F7</kbd>，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择。</p>
<p><kbd>Ctrl</kbd>+<kbd>N</kbd>，可以快速打开类。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>N</kbd>，可以快速打开文件。</p>
<p><kbd>Alt</kbd>+<kbd>Q</kbd>，可以看到当前方法的声明。</p>
<p><kbd>Ctrl</kbd>+<kbd>P</kbd>，可以显示参数信息。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Insert</kbd>，可以选择剪贴板内容并插入。</p>
<p><kbd>Alt</kbd>+<kbd>Insert</kbd>，可以生成构造器/Getter/Setter等。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>V</kbd>，可以引入变量。例如：new String(); 自动导入变量定义。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>T</kbd>，可以把代码包在一个块内，例如：try/catch。</p>
<p><kbd>Ctrl</kbd>+<kbd>Enter</kbd>，导入包，自动修正。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>L</kbd>，格式化代码。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>I</kbd>，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>O</kbd>，优化导入的类和包。</p>
<p><kbd>Ctrl</kbd>+<kbd>R</kbd>，替换文本。</p>
<p><kbd>Ctrl</kbd>+<kbd>F</kbd>，查找文本。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Space</kbd>，自动补全代码。</p>
<p><kbd>Ctrl</kbd>+<kbd>空格</kbd>，代码提示（与系统输入法快捷键冲突）。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>N</kbd>，查找类中的方法或变量。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>，最近的更改。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>Up</kbd>/<kbd>Down</kbd>，上/下移一行。</p>
<p><kbd>Shift</kbd>+<kbd>F6</kbd>，重构 – 重命名。</p>
<p><kbd>Ctrl</kbd>+<kbd>X</kbd>，删除行。</p>
<p><kbd>Ctrl</kbd>+<kbd>D</kbd>，复制行。</p>
<p><kbd>Ctrl</kbd>+<kbd>/</kbd>或<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>/</kbd>，注释（//或者/**/）。</p>
<p><kbd>Ctrl</kbd>+<kbd>J</kbd>，自动代码（例如：serr）。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>J</kbd>，用动态模板环绕。</p>
<p><kbd>Ctrl</kbd>+<kbd>H</kbd>，显示类结构图（类的继承层次）。</p>
<p><kbd>Ctrl</kbd>+<kbd>Q</kbd>，显示注释文档。</p>
<p><kbd>Alt</kbd>+<kbd>F1</kbd>，查找代码所在位置。</p>
<p><kbd>Alt</kbd>+<kbd>1</kbd>，快速打开或隐藏工程面板。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>left</kbd>/<kbd>right</kbd>，返回至上次浏览的位置。</p>
<p><kbd>Alt</kbd>+<kbd>left</kbd>/<kbd>right</kbd>，切换代码视图。</p>
<p><kbd>Alt</kbd>+<kbd>Up</kbd>/<kbd>Down</kbd>，在方法间快速移动定位。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Up</kbd>/<kbd>Down</kbd>，向上/下移动语句。</p>
<p><kbd>F2</kbd> 或 <kbd>Shift</kbd>+<kbd>F2</kbd>，高亮错误或警告快速定位。</p>
<p><kbd>Tab</kbd>，代码标签输入完成后，按 Tab，生成代码。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F7</kbd>，高亮显示所有该文本，按 Esc 高亮消失。</p>
<p><kbd>Alt</kbd>+F3，逐个往下查找相同文本，并高亮显示。</p>
<p><kbd>Ctrl</kbd>+<kbd>Up</kbd>/<kbd>Down</kbd>，光标中转到第一行或最后一行下。</p>
<p><kbd>Ctrl</kbd>+<kbd>B</kbd>/<kbd>Ctrl</kbd>+<kbd>Click</kbd>，快速打开光标处的类或方法（跳转到定义处）。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>B</kbd>，跳转到方法实现处。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Backspace</kbd>，跳转到上次编辑的地方。</p>
<p><kbd>Ctrl</kbd>+<kbd>O</kbd>，重写方法。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Space</kbd>，类名自动完成。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Up</kbd>/<kbd>Down</kbd>，快速跳转搜索结果。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>J</kbd>，整合两行。</p>
<p><kbd>Alt</kbd>+<kbd>F8</kbd>，计算变量值。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd>，可以将最近使用的剪贴板内容选择插入到文本。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd>，简单粘贴。</p>
<p><kbd>Shift</kbd>+<kbd>Esc</kbd>，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口。</p>
<p><kbd>F12</kbd>，把焦点从编辑器移到最近使用的工具窗口。</p>
<p><kbd>Shift</kbd>+<kbd>F1</kbd>，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器。</p>
<p><kbd>Ctrl</kbd>+<kbd>W</kbd>，可以选择单词继而语句继而行继而函数。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>W</kbd>，取消选择光标所在词。</p>
<p><kbd>Alt</kbd>+<kbd>F7</kbd>，查找整个工程中使用地某一个类、方法或者变量的位置。</p>
<p><kbd>Ctrl</kbd>+<kbd>I</kbd>，实现方法。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>U</kbd>，大小写转化。</p>
<p><kbd>Ctrl</kbd>+<kbd>Y</kbd>，删除当前行。</p>
<p><kbd>Shift</kbd>+<kbd>Enter</kbd>，向下插入新行。</p>
<p>psvm/sout，main/System.out.println(); <kbd>Ctrl</kbd>+<kbd>J</kbd>，查看更多。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F</kbd>，全局查找。</p>
<p><kbd>Ctrl</kbd>+<kbd>F</kbd>，查找/<kbd>Shift</kbd>+F3，向上查找/F3，向下查找。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd>，高级搜索。</p>
<p><kbd>Ctrl</kbd>+<kbd>U</kbd>，转到父类。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>S</kbd>，打开设置对话框。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>Inert</kbd>，开启/关闭列选择模式。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd>，打开当前项目/模块属性。</p>
<p><kbd>Ctrl</kbd>+<kbd>G</kbd>，定位行。</p>
<p><kbd>Alt</kbd>+<kbd>Home</kbd>，跳转到导航栏。</p>
<p><kbd>Ctrl</kbd>+<kbd>Enter</kbd>，上插一行。</p>
<p><kbd>Ctrl</kbd>+<kbd>Backspace</kbd>，按单词删除。</p>
<p><kbd>Ctrl</kbd>+<kbd>”+/-”</kbd>，当前方法展开、折叠。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>”+/-”</kbd>，全部展开、折叠。</p>
<h4 id="调试部分、编译"><a href="#调试部分、编译" class="headerlink" title="调试部分、编译"></a>调试部分、编译</h4><p><kbd>Ctrl</kbd>+<kbd>F2</kbd>，停止。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>F9</kbd>，选择 Debug。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>F10</kbd>，选择 Run。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F9</kbd>，编译。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F10</kbd>，运行。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F8</kbd>，查看断点。</p>
<p><kbd>F8</kbd>，步过。</p>
<p><kbd>F7</kbd>，步入。</p>
<p><kbd>Shift</kbd>+<kbd>F7</kbd>，智能步入。</p>
<p><kbd>Shift</kbd>+<kbd>F8</kbd>，步出。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>F8</kbd>，强制步过。</p>
<p><kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>F7</kbd>，强制步入。</p>
<p><kbd>Alt</kbd>+<kbd>F9</kbd>，运行至光标处。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F9</kbd>，强制运行至光标处。</p>
<p><kbd>F9</kbd>，恢复程序。</p>
<p><kbd>Alt</kbd>+<kbd>F10</kbd>，定位到断点。</p>
<p><kbd>Ctrl</kbd>+<kbd>F8</kbd>，切换行断点。</p>
<p><kbd>Ctrl</kbd>+<kbd>F9</kbd>，生成项目。</p>
<p><kbd>Alt</kbd>+<kbd>1</kbd>，项目。</p>
<p><kbd>Alt</kbd>+<kbd>2</kbd>，收藏。</p>
<p><kbd>Alt</kbd>+<kbd>6</kbd>，TODO。</p>
<p><kbd>Alt</kbd>+<kbd>7</kbd>，结构。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>，复制路径。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>，复制引用，必须选择类名。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Y</kbd>，同步。</p>
<p><kbd>Ctrl</kbd>+<kbd>~</kbd>，快速切换方案（界面外观、代码风格、快捷键映射等菜单）。</p>
<p><kbd>Shift</kbd>+<kbd>F12</kbd>，还原默认布局。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F12</kbd>，隐藏/恢复所有窗口。</p>
<p><kbd>Ctrl</kbd>+<kbd>F4</kbd>，关闭。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F4</kbd>，关闭活动选项卡。</p>
<p><kbd>Ctrl</kbd>+<kbd>Tab</kbd>，转到下一个拆分器。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Tab</kbd>，转到上一个拆分器。</p>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>T</kbd>，弹出重构菜单。</p>
<p><kbd>Shift</kbd>+<kbd>F6</kbd>，重命名。</p>
<p><kbd>F6</kbd>，移动。</p>
<p><kbd>F5</kbd>，复制。</p>
<p><kbd>Alt</kbd>+<kbd>Delete</kbd>，安全删除。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>N</kbd>，内联。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p><kbd>Ctrl</kbd>+<kbd>F</kbd>，查找。</p>
<p><kbd>Ctrl</kbd>+<kbd>R</kbd>，替换。</p>
<p><kbd>F3</kbd>，查找下一个。</p>
<p><kbd>Shift</kbd>+<kbd>F3</kbd>，查找上一个。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F</kbd>，在路径中查找。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>R</kbd>，在路径中替换。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>S</kbd>，搜索结构。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd>，替换结构。</p>
<p><kbd>Alt</kbd>+<kbd>F7</kbd>，查找用法。</p>
<p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F7</kbd>，显示用法。</p>
<p><kbd>Ctrl</kbd>+<kbd>F7</kbd>，在文件中查找用法。</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F7</kbd>，在文件中高亮显示用法。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-习题1</title>
    <url>/lzfangwen.github.io/2020/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B9%A0%E9%A2%981/</url>
    <content><![CDATA[<p><strong>学习通 老师布置的第三章的题目 有关 安全序列 银行家算法</strong></p>
<a id="more"></a>

<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200409/op1yvQCI6DKH.png" alt="mark"></p>
<p>(1)</p>
<table>
<thead>
<tr>
<th>进程</th>
<th align="center">最大需求数</th>
<th align="center">已占有资源</th>
<th align="center">最多还需要</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td align="center">5     5     9</td>
<td align="center">2     1     2</td>
<td align="center">3     4     7</td>
</tr>
<tr>
<td>P2</td>
<td align="center">5     4     6</td>
<td align="center">4     0     2</td>
<td align="center">1     4     4</td>
</tr>
<tr>
<td>P3</td>
<td align="center">4     0     11</td>
<td align="center">4     0     5</td>
<td align="center">0     0     6</td>
</tr>
<tr>
<td>P4</td>
<td align="center">4     2     5</td>
<td align="center">2     0     4</td>
<td align="center">2     2     1</td>
</tr>
<tr>
<td>P5</td>
<td align="center">8     2     4</td>
<td align="center">3     1     4</td>
<td align="center">5     1     0</td>
</tr>
</tbody></table>
<p>$T_0$时刻 系统剩余资源 Available=(2,3,3)</p>
<p>现在系统处于安全状态</p>
<p>安全序列：P4，P3，P5，P1，P2</p>
<p>（2）</p>
<p>$T_0$时刻P4提出（2,0,1）请求后 系统剩余资源 Available=(0,3,2)  可以满足P1提出的（0,2,0）请求</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200409/s0UEB8LiFJI3.png" alt="mark"></p>
<p>（1）</p>
<table>
<thead>
<tr>
<th>Process    进程</th>
<th align="center">Max                 最大需求</th>
<th align="center">Allocation               已分配</th>
<th align="center">Need                         最多还需要</th>
<th>Available               系统可用资源</th>
</tr>
</thead>
<tbody><tr>
<td>$p_0$</td>
<td align="center">(0,0,4,4)</td>
<td align="center">(0,0,3,2)</td>
<td align="center">(0,0,1,2)</td>
<td>(1,6,2,2)</td>
</tr>
<tr>
<td>$p_1$</td>
<td align="center">(2,7,5,0)</td>
<td align="center">(1,0,0,0)</td>
<td align="center">(1,7,5,0)</td>
<td></td>
</tr>
<tr>
<td>$p_2$</td>
<td align="center">(3,6,10,10)</td>
<td align="center">(1,3,5,4)</td>
<td align="center">(2,3,5,6)</td>
<td></td>
</tr>
<tr>
<td>$p_3$</td>
<td align="center">(0,9,8,4)</td>
<td align="center">(0,3,3,2)</td>
<td align="center">(0,6,5,2)</td>
<td></td>
</tr>
<tr>
<td>$p_4$</td>
<td align="center">(0,6,6,10)</td>
<td align="center">(0,0,1,4)</td>
<td align="center">(0,6,5,6)</td>
<td></td>
</tr>
</tbody></table>
<p>安全序列：$p_0$，$p_3$，$p_4$，$p_1$，$p_2$</p>
<p>系统是安全的</p>
<p>(2)$p_2$的请求Request(1,2,2,2)</p>
<p>假如系统分配后 $p_2$ Need(1,1,3,4)</p>
<p>​                                Available(0,4,0,0)    </p>
<p>系统陷入死锁        所以系统不能将资源分配给它</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习笔记3</title>
    <url>/lzfangwen.github.io/2020/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p><img src="https://img-blog.csdnimg.cn/20200321215121803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200321215616103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p><img src="https://img-blog.csdnimg.cn/20200321215708658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h3><p><img src="https://img-blog.csdnimg.cn/20200321220025428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>指CPU忙碌 的时间占总时间的比例<br><img src="https://img-blog.csdnimg.cn/20200321221647667.png" alt="在这里插入图片描述"></p>
<h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>指单位时间内完成作业的数量<br><img src="https://img-blog.csdnimg.cn/2020032122170056.png" alt="在这里插入图片描述"></p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p> 指从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔<br> <img src="https://img-blog.csdnimg.cn/20200321220753841.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200321220859207.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200321221708381.png" alt="在这里插入图片描述"></p>
<h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><p> 指进程/作业<strong>处于等待处理机状态时间之和</strong><br>等待时间=周转时间-运行时间-I/O操作的时间<img src="https://img-blog.csdnimg.cn/20200321221739884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p> 指用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p> <img src="https://img-blog.csdnimg.cn/20200322103738586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322111605743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="先来先服务算法（FCDS，First-Come-FIrst-Serve）"><a href="#先来先服务算法（FCDS，First-Come-FIrst-Serve）" class="headerlink" title="先来先服务算法（FCDS，First Come FIrst Serve）"></a>先来先服务算法（FCDS，First Come FIrst Serve）</h3><p> <img src="https://img-blog.csdnimg.cn/20200322101814472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322102610499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="短作业优先（SJF，Shortest-Job-First）"><a href="#短作业优先（SJF，Shortest-Job-First）" class="headerlink" title="短作业优先（SJF，Shortest Job First）"></a>短作业优先（SJF，Shortest Job First）</h3><p> <img src="https://img-blog.csdnimg.cn/20200322102933743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322102507330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200322102354444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="高响应优先（HRRN，Highest-Response-Ratio-Next）"><a href="#高响应优先（HRRN，Highest-Response-Ratio-Next）" class="headerlink" title="高响应优先（HRRN，Highest Response Ratio Next）"></a>高响应优先（HRRN，Highest Response Ratio Next）</h3><p> <img src="https://img-blog.csdnimg.cn/20200322103713380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322103723522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="时间片轮转调度算法（RR，Round-Robin）"><a href="#时间片轮转调度算法（RR，Round-Robin）" class="headerlink" title="时间片轮转调度算法（RR，Round-Robin）"></a>时间片轮转调度算法（RR，Round-Robin）</h3><p> <img src="https://img-blog.csdnimg.cn/2020032210572321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322105826975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p> <img src="https://img-blog.csdnimg.cn/20200322110647521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020032211023247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322110243922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322110658166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p> <img src="https://img-blog.csdnimg.cn/20200322111151807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200322111410276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="【"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记5</title>
    <url>/lzfangwen.github.io/2020/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p> <strong>算法思想</strong>：两个进程在 <strong>访问临界区</strong>后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<p>可以实现<strong>同一时刻最多只允许一个进程访问临界区</strong></p>
<a id="more"></a>

<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200404/nKcso4kGwe3k.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200404/4x9YuXGhPP0u.png" alt="mark"></p>
<h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p><strong>算法思想</strong>:设置一个布尔型数组flag[],数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>,比如”flag[0] = ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志flag[i]设为true,之后开始访问临界区</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200404/MiE9vSwfBeyM.png" alt="mark"></p>
<h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p><strong>算法思想</strong>:双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁” ,但是这两个操作又无法一气呵成,因此导致了两个进程同时进入临界区的问题。因此,人们又想到先“上锁”后“检查”的方法,来避免上述问题。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200404/4GA1JprzUCye.png" alt="mark"></p>
<h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p><strong>算法思想</strong>:双标志后检查法中,两个进程都争着想进入临界区,但是谁也不让谁,最后谁都无法进入临界区。Gary L. Peterson想到了一种方法,如果双方都争着想进入临界区,那可以让进程尝试“孔融上梨”,主动让对方先使用临界区</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200404/rkM7I9IHo9os.png" alt="mark"></p>
<h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p>利用“开/关中断指令”实现(与原语的实现思想相同,即在某进程开始访问临界区到结束访问为止都不允许被中断,也就不能发生进程切换,因此也不可能发生两个同时访问临界区的情况)</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/51PVmEsdA5RT.png" alt="mark"></p>
<p>优点:简单、高效缺点:不适用于多处理机;只适用于操作系统内核进程,不适用于用户进程(因为开/关中断指令只能运行在内核态,这组指令如果能让用户随意使用会很危险)</p>
<h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p>简称TS指令,也有地方称为TestAndSetLock指令,或TSL指令</p>
<p><strong>TSL指令是用硬件实现的,</strong>执行的过程不允许被中断,只能一气呵成。以下是用C语言描述的逻辑</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/sQ8lDEHKqj1q.png" alt="mark"></p>
<p>若刚开始lock是false,则TSL返回的old值为false, while循环条件不满足,直接跳过循环,进入临界区。若刚开始lock是true,则执行TLS后old返回的值为true, while循环条件满足,会一直循环,直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法, TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
<p>优点:实现简单,无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境</p>
<p>缺点:不满足“让权等待”原则,暂时无法进入临界区的进程会占用CPU并循环执行TSL指令,从而导致“忙等”</p>
<h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p>有的地方也叫Exchange指令,或简称XCHG指令。<strong>swap指令是用硬件实现的</strong>,执行的过程不允许被中断,只能一气呵成。以下是用C语言描述的逻辑</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/r8sga0kfPgEh.png" alt="mark"></p>
<p>逻辑上来看Swap和TSL并无太大区别,都是先记录下此时临界区是否已经被上锁(记录在old变量上) ,再将上锁标记lock设置为true,最后检查old,如果old为false则说明之前没有别的进程,对临界区上锁,则可跳出循环,进入临界区。</p>
<p>优点:实现简单,无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境</p>
<p>缺点:不满足“让权等待”原则,暂时无法进入临界区的进程会占用CPU并循环执行TSL指令,从而导致“忙等”。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记2</title>
    <url>/lzfangwen.github.io/2020/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h2><a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/2020031316272059.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h2><p><img src="https://img-blog.csdnimg.cn/20200313163136346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200313163144468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p><img src="https://img-blog.csdnimg.cn/20200313162759444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p><img src="https://img-blog.csdnimg.cn/20200313163722388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020031316381162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200320101837346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="进程的组织形式"><a href="#进程的组织形式" class="headerlink" title="进程的组织形式"></a>进程的组织形式</h2><p><img src="https://img-blog.csdnimg.cn/20200320102130397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>进程与程序的区别</strong><br><img src="https://img-blog.csdnimg.cn/20200313165514735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>特性</strong><br><img src="https://img-blog.csdnimg.cn/20200313165610535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h2><p>三种基本状态</p>
<ul>
<li><strong>就绪状态(Ready)</strong><br>得到了除CPU以外的所有必要资源</li>
<li><strong>执行状态(Running)</strong><br>已获得处理机，程序正在被执行</li>
<li><strong>堵塞状态(Waiting/Blocked,又称等待态)</strong><br>因等待某事件发生而暂时无法继续执行，从而放弃处理机，使程序执行处于暂停状态<br><img src="https://img-blog.csdnimg.cn/20200320103846258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020032010381917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><img src="https://img-blog.csdnimg.cn/20200320104832851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><strong>进程之间的信息交换</strong><br><img src="https://img-blog.csdnimg.cn/20200320105838352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2></li>
</ul>
<p> <strong>线程是一个基本的CPU执行单元 ，也是程序执行流的最小单位</strong><br> <img src="https://img-blog.csdnimg.cn/20200320110828452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200320111301772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200320112545394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>设置进程同步机制四条规则</strong></p>
<p>进程在并发执行时为了保证结果的可再现性，各进程执行序列必须加以限制以保证互斥地使用临界资源，相互合作完成任务。多个相关进程在执行次序上的协调称为进程同步。用于保证多个进程在执行次序上的协调关系的相应机制称为进程同步机制。</p>
<p>所有的进程同步机制应遵循下述四条准则：</p>
<ul>
<li><strong>空闲让进</strong><br>当无进程进入临界区时，相应的临界资源处于空闲状态，因而允许一个请求进入临界区的进程立即进入自己的临界区。</li>
<li><strong>忙则等待</strong><br>当已有进程进入自己的临界区时，即相应的临界资源正被访问，因而其它试图进入临界区的进程必须等待，以保证进程互斥地访问临界资源。</li>
<li><strong>有限等待</strong><br>对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。</li>
<li><strong>让权等待</strong><br>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等。</li>
</ul>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p><strong>每个进程中访问临界资源的那段代码称为临界区</strong>（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。<br>多个进程中涉及到同一个临界资源的临界区称为相关临界区。.</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p><img src="https://img-blog.csdnimg.cn/2020032011364476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200320113935411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h3><p><img src="https://img-blog.csdnimg.cn/20200320113916159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记4</title>
    <url>/lzfangwen.github.io/2020/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YE411D7nH?p=31" target="_blank" rel="noopener">b站王道考研 OS</a> p28~p31学习笔记 仅方便自己复习用 侵删</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.</p>
<a id="more"></a>

<h3 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h3><p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。<br>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） <strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行被剥夺。<br>（4） <strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h3 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h3><p>死锁:各进程互相等待对方手里的资源,导致各进程都阻塞,无法向前推进的现象。</p>
<p>饥饿:由于长期得不到想要的资源,某进程无法向前推进的现象。比如:在短进程优先(SPF)算法中,若有源源不断的短进程到来,则长进程将一直得不到处理机,从而发生长进程“饥饿”</p>
<p>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的,有时是程序员故意设计的。</p>
<table>
    <tbody><tr>
        <td></td>
        <td>共同点</td>
        <td>区别</td>
    </tr>
    <tr>
        <td>死锁</td><td rowspan="3">都是进程无法顺利向前推进的现象（故意设计的死循环除外）</td>
        <td>死锁一定是“循环等待对方手中的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定 处于阻塞态。</td>
    </tr>
    <tr>
        <td>饥饿</td><td>可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态（如长期得不到I/O设备），也可能是就绪态（长期得不到处理机）</td>
    </tr>
    <tr>
        <td>死循环</td>
        <td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态) ,只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的,而死循环是由代码逻辑的错误导致的。死锁和饥饿是管理者（操作系统）问题,死循环是被管理者的问题。</td>
    </tr>
</tbody></table>

<h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li><p><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁,对可剥夺的资源(CPU)的竞争是不会引起死锁的</p>
</li>
<li><p><strong>程序推进顺序非法</strong>。请求和释放资源的顺序不当,也同样会导致死锁。例如,并发执行的进程P1、P2分别申请并占有了资源R1,R2,之后进程P1又紧接着申请资源R2,而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞,从而发生死锁。</p>
</li>
<li><p><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中,如果实现互斥的P操作在实现同步的P操作之前,就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</p>
<p>总之,对不可剥夺资源的不合理分配,可能导致死锁。</p>
</li>
</ol>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><ol>
<li><strong>预防死锁</strong>。破坏死锁产生的四个必要条件中的一个或几个。</li>
<li><strong>避免死锁</strong>。用某种方法防止系统进入不安全状态,从而避免死锁(银行家算法)</li>
<li><strong>死锁的检测和解除</strong>。允许死锁的发生,不过操作系统会负责检测出死锁的发生,然后采取某种措施解除死锁。</li>
</ol>
<h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a><strong>破坏互斥条件</strong></h4><p>spooling技术</p>
<h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a><strong>破坏不剥夺条件</strong></h4><p>进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主动释放。</p>
<p>方案一:当某个进程请求新的资源得不到满足时,它必须立即释放保持的所有资源,待以后需要时再重新申请。也就是说,即使某些资源尚未使用完,也需要主动释放,从而破坏了不可剥夺条件。</p>
<p>方案二:当某个进程需要的资源被其他进程所占有的时候,可以由操作系统协助,将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式,就是将处理机资源强行剥夺给优先级更高的进程使用)</p>
<p><strong>该策略的缺点</strong>:</p>
<ol>
<li>实现起来比较复杂。</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源,如CPU</li>
<li>反复地申请和释放资源会增加系统开销,降低系统吞吐量。</li>
<li>若采用方案一,意味着只要暂时得不到某个资源,之前获得的那些资源就都需要放弃,以后再重新申请。如果一直发生这样的情况,就会导致进程饥饿。</li>
</ol>
<h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a><strong>破坏请求和保持条件</strong></h4><p>进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程占有,此时请求进程被阻塞,但又对自己己有的资源保持不放。</p>
<p>可以采用<strong>静态分配方法</strong>,即进程在运行前一次申请完它所需要的全部资源,在它的资源未满足前,,不让它投入运行。一旦投入运行后,这些资源就一直归它所有,该进程就不会再请求别的任何资源</p>
<p>该策略实现起来简单,但也有明显的缺点有些资源可能只需要用很短的时间,因此如果进程的整个运行期间都一直保持着所有资源,就会造成严重的资源浪费<strong>资源利用率极低</strong>。另外,该策略也有可能<strong>导致某些进程饥饿</strong>。</p>
<h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>循环等待条件:存在一种进程资源的循环等待链,链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号,规定每个进程必须按编号递增的顺序请求资源,同类资源(即编号相同的资源)一次申请完。原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象。</p>
<p>该策略的缺点:</p>
<ol>
<li>不方便增加新的设备,因为可能需要重新分配所有的编号;</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致,会导致资源浪费;</li>
<li>必须按规定次序申请资源,用户编程麻烦。</li>
</ol>
<h2 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h2><h3 id="安全序列"><a href="#安全序列" class="headerlink" title="安全序列"></a>安全序列</h3><p>所谓安全序列,就是指如果系统按照这种序列分配资源,则每个进程都能顺利完成。只要能找出一个安全序列,系统就是安全状态。当然,安全序列可能有多个如果分配了资源之后,系统中找不出任何一个安全,,系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然,如果,进程提前归还了一些资源,那系统也有可能重新1安全不i我们在分配资源之</p>
<p> 如果系统处于安全状态,就一定不会发生死锁。如果系统进入不安全状态,就可能发生死锁(处于不安全状态未必就是发生了死锁,但发生死锁时一定是在不安全状态)因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态,以此决定是否答应资源</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>数据结构</strong>：</p>
<ul>
<li>长度为m的一维数组Available表示还有多少可用资源</li>
<li>n<em>*m矩阵Max表示各进程对资源的最大需求数</em></li>
<li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li>
<li>Max-Allocation = Need矩阵表示各进程最多还需要多少资源</li>
<li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li>
</ul>
<p><strong>银行家算法步骤:</strong></p>
<ol>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探着分配,更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ol>
<p><strong>安全性算法步骤：</strong></p>
<p>​    检查当前的剩余可用资源是否能满足某个进程的最欧需求,如果可以,就把该进程加入安全序列,并把该进程持有的资源全部回收。</p>
<p>eg</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200401/EmlzwDP1stjB.png" alt="mark"></p>
<h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>为了能对系统是否己发生了死锁进行检测,必须:</p>
<ol>
<li><p>用某种数据结构来保存资源的请求和分配信息;</p>
</li>
<li><p>提供一种算法,利用上述信息来检测系统是否已进入死锁状态</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200401/fBCBVqXHx7ud.png" alt="mark"></p>
</li>
</ol>
<p>检测死锁的算法</p>
<ol>
<li>在资源分配图中,找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中, R1没有空闲资源, R2有一个空闲资源。若所有的连接该进程的边均满足上述条件,则这个进程能继续运行直至完成,然后释放它所占有的所有资源)。消去它所有的请求边和分配变,使之称为孤立的结点。在上图中,P1是满足这一条件的进程结点,于是将P1的所有边消去。</li>
<li>进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变,为非阻塞进程。在下图中, P2就满足这样的条件。根据1)中的方法进行一系列简化后,若能消去途中所有的边,则称该图是可完全简化的。</li>
</ol>
<h4 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h4><p>一旦检测出死锁的发生,就应该立即解除死锁。</p>
<p>补充:并不是系统中所有的进程都是死锁状态,用死锁检测算法化简资源分配图后,还连着边的那些进程就是死锁进程</p>
<p>解除死锁的主要方法有:</p>
<ol>
<li><strong>资源剥夺法</strong>。挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>(或称<strong>终止进程法</strong>)。强制撤销部分、甚至全部死锁进程,并剥夺这些进程的资源。这种方式的优点是实现简单,但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间,已经接近结束了,一旦被终止可谓功亏一篑,以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史记录，设置还原点</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记6</title>
    <url>/lzfangwen.github.io/2020/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/</url>
    <content><![CDATA[<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作,从而很方便的实现了进程互斥、进程同步。</p>
<p><strong>信号量</strong>其实就是一个变量(可以是一个整数,也可以是更复杂的记录型变量),可以用一个信号量来<strong>表示系统中某种资源的数量</strong>,比如:系统中只有一台打印机,就可以设置一个初值为1的信号量</p>
<p><strong>原语</strong>是一种特殊的程序段,其<strong>执行只能一气呵成,不可被中断</strong>。原语是由<strong>关中断/开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成” ,因此如果能把进入区、退作都用“原语”这些操作能“一气呵成”就能避免问题</p>
<a id="more"></a>

<p>一对原语: <strong>wait(S)</strong>原语和<strong>signal(S)</strong>原语,可以把原语理解为我们自己写的函数,函数名分别为wait和signal,括号里的<strong>信号量S</strong>其实就是函数调用时传入的一个参数。</p>
<p>wait, signal原语常<strong>简称为P、V操作</strong>(来自荷兰语proberen和verhogen) 。因此,做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、v(S)</p>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>用一个<strong>整数型的变量</strong>作为信号量，用来表示系统中某种资源的数量。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，初始化、P操作、V操作</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/vQcqEgpVyiX2.png" alt="mark"></p>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题,因此人们又提出了“记录型信号量” ,即用记录型数据结构表示的信号量。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/xFbfQ2XoSTEn.png" alt="mark"></p>
<p>在考研题目中wait(s)、 signal()也可以记为P(S)、V(S),这对原语可用于<strong>实现系统资源的“申请”和“释放”</strong></p>
<p><strong>S.value的初值</strong>表示系统中某种资源的数目。</p>
<p>对信号量s的<strong>一次P操作</strong>意味着进程<strong>请求V一个单位的该类资</strong>源,因此需要执行S.value–,表示资源数减1,当S.value &lt;0时表示该类资源已分配完毕,因此进程应<strong>调用block原语进行自我阻塞</strong>(当前运行的进程从<strong>运行态→阻塞态</strong>) ,主动放弃处理机,并插入该类资源的等待队列S.L中。可见,该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</p>
<p>对信号量s的<strong>一次V操作意味</strong>着进程<strong>释放一个单位的该类资源</strong>,因此需要执行s.value++,表示资源数加1,若加1后仍是S.value &lt;-0,表示依然有进程在等待该类资源,因此应<strong>调用wakeup原语唤醒等待队列中的第1个进程</strong>(被唤醒进程从<strong>阻塞态→就绪态</strong>)</p>
<h2 id="用信号量机制实现进程互斥、同步、前驱关系"><a href="#用信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量机制实现进程互斥、同步、前驱关系"></a>用信号量机制实现进程互斥、同步、前驱关系</h2><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/cUpoPSPURO2z.png" alt="mark"></p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/HNWT5QLI2Pgx.png" alt="mark"></p>
<h3 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/X3vDETalxf78.png" alt="mark"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统知识点</title>
    <url>/lzfangwen.github.io/2020/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<a id="more"></a>

<p>段页式存储管理方式</p>
<ul>
<li><p>优点</p>
<ul>
<li>很方便按照逻辑模块实现信息的共享和保护</li>
<li>方便用户编程</li>
<li>有利于信息的动态增长和动态连接</li>
<li>内部空间利用率高，不会产生外部碎片，只会有少量的页内碎片</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>需要3次访问内存，复杂性和开销增加，需要的硬件以及占用的内存也有所增加，使得执行速度下降。</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>操作系统-学习笔记7</title>
    <url>/lzfangwen.github.io/2020/04/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/</url>
    <content><![CDATA[<h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><p>系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者,进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)生产者、消费者共享一个<strong>初始为空、大小为n的缓冲区</strong>。</p>
<p>只有缓冲区没满时,生产者才能把产品放入缓冲区,否则必须等待。</p>
<p>只有缓冲区不空时,消费者才能从中取出产品,否则必须等待。</p>
<p>缓冲区是临界资源,<strong>各进程必须互斥地访问</strong>。</p>
<a id="more"></a>

<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/sTX4f7vOIavn.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/qgByT9YI8llH.png" alt="mark"></p>
<p><strong>实现互斥的P操作一定要在实现同步的P操作之后</strong></p>
<p>V操作不会导致进程阻塞，因此两个V操作顺序可以交换</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200405/0A4f6z2oszli.png" alt="mark"></p>
<h2 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h2><p>桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/t5GvRuDas2En.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/bm7Iwt05IMiy.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/pBMktfFR9GF9.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/SppmnSNjAx4D.png" alt="mark"></p>
<p>原因在于:本题中的缓冲区大小为1,在任何时刻, apple, orange, plate三个同步信号量中最多只有一个是1,因此在任何时刻,最多只有一个进程的P操作不会被阻塞,并顺利地进入临界区…</p>
<p><strong>总结:</strong>在生产者-消费者问题中,如果缓冲区大小为1,那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然,这不是绝对的,要具体问题具体分析。</p>
<p>建议:在考试中如果来不及仔细分析,可以加上互斥信号量,保证各进程一定会互斥地访问缓冲区。但需要注意的是,实现互斥的P操作一定要在实现同步的P操作之后,否则可能引起“死锁”PV<strong>操作题目的解题思路:</strong></p>
<ol>
<li>关系分析。找出题目中描述的各个进程,分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量,并根据题目条件确定信号量初值。(互斥信号量初值一般为1,同步信号量的初始值要看对应资源的初始值是多少)</li>
</ol>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/rtMKz5svYszz.png" alt="mark"></p>
<h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草、,第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流抽烟）</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/f0YnUJdo0VET.png" alt="mark"></p>
<p><strong>问题分析</strong></p>
<p>本质上这题也属于“生产者-消费者”问题,更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p>
<ol>
<li>关系分析。找出题目中描述的各个进程,分析它们之间的同步、互斥关系。</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
</ol>
<p>桌子可以抽象为容量为1的缓冲区，要互斥访问</p>
<p>三种材料 可以抽象为三种组合</p>
<p>​    组合一：纸+胶水</p>
<p>​    组合二:烟草+胶水</p>
<p>​    组合三:烟草+纸</p>
<p>同步关系（要从事件的角度分析）</p>
<p>​    桌子上有组合一    →    第一个抽烟者取走东西</p>
<p>​    桌子上有组合二    →    第二个抽烟者取走东西</p>
<p>​    桌子上有组合三    →    第三个抽烟者取走东西</p>
<p>​    发出完成信号        →    供应者将下一个组合放在桌上</p>
<p>​        PV操作顺序 “前V后P”</p>
<p>​        (必须发生在前面的事件之后执行V操作，必须发生在后面的事件之前执行P操作)</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/kFNJqbY66BmN.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/twBBqexItxDH.png" alt="mark"></p>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>有读者和写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致·数据不一致的错误。</p>
<p>因此要求: </p>
<ol>
<li>允许多个读者可以同时对文件执行读操作; </li>
<li>只允许一个写者往文件中写信息; </li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作;</li>
<li>写者执行写操作,应让已有的读者和写者全部退出。</li>
</ol>
<p><strong>问题分析</strong></p>
<p>两类进程:写进程、读进程</p>
<p>互斥关系:写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题</p>
<p>写者进程和任何进程都互斥,设置一个互斥信号量rw,在写者访问共享文件前后分别执行P, V操作。</p>
<p>读者进程和写者进程也要互斥,因此读者访问共享文件前后也要对rw执行P、V操作。</p>
<p>如果所有读者进程在访问共享文件之前都执行P(rw)操作,那么会导致各个读进程之间也无法同时访问文件。</p>
<p><strong>Key:读者写者问题的核心思想–怎么处理该问题呢?</strong></p>
<p>P(rw)和Vrw)其实就是对共享文件的“加锁”和”解锁” 。既然各个读进程需要同时访问,而读进程与写进程又必须互斥访间,那么我们可以让第一个访问文件的读进程“加锁” ,让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/mogqygCIeL4m.png" alt="mark"></p>
<p>读进程源源不断会导致写进程饿死</p>
<p>解决方法：</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/38XxSpldwRzG.png" alt="mark"></p>
<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p>
<p>其<strong>核心思想</strong>在于设置了一个<strong>计数器count</strong>用来记录当前正在访间共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程,从而做出不同的处理。</p>
<p>另外,对count变量的检查和赋值不能一气呵成导致了一些错误,如果<strong>需要实现“一气呵成”,自然应该想到用互斥信号量。</strong></p>
<p>最后,还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决,如果遇到更复杂的问题,可以想想能否用读者写者问题的这几个思想来解决。</p>
<h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>张圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时,才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/WCHmiiXhRtMz.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200406/ahbISrdfq3o3.png" alt="mark"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记8</title>
    <url>/lzfangwen.github.io/2020/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/</url>
    <content><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h2><p>内存是用于存放数据的硬件。程序执行前<strong>需要先放到内存中才能被CPU处理</strong></p>
<ul>
<li>内存地址从0开始,<strong>每个地址对应一个存储单元</strong></li>
<li>如果计算机“<strong>按字节编址</strong>”则每个存储单元大小为1字节,即18,即8个二进制位</li>
<li>如果字长为16位的计算机<strong>,按字编址</strong>” ,则每个存储单元大小为1个字;每个字的犬小为16个二进制位</li>
</ul>
<a id="more"></a>

<h3 id="进程的运行原理"><a href="#进程的运行原理" class="headerlink" title="进程的运行原理"></a>进程的运行原理</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/po5UOteElwQR.png" alt="mark"></p>
<p>可见,我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据,这个数据应该做什么样的处理。在这个例子中,指令中直接给出了变量x的实际存放地址(物理地址)但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用<strong>逻辑地址(相对地址)</strong></p>
<h3 id="从写程序到程序运行"><a href="#从写程序到程序运行" class="headerlink" title="从写程序到程序运行"></a>从写程序到程序运行</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/ohp5gwJxi5E6.png" alt="mark"></p>
<p>编译:由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</p>
<p>链接:由链接程序将编译后形成的一组目标模块,以及所需库函数链接在一起,形成一个完整的装入模块装入(装载) :由装入程序将装入模块装入内存运行</p>
<h3 id="装入模块装入内存"><a href="#装入模块装入内存" class="headerlink" title="装入模块装入内存"></a>装入模块装入内存</h3><p>装入的三种方式(用三种不同的方法完成逻辑地址到物理地址的转换) :</p>
<ol>
<li><p><strong>绝对装入</strong></p>
<blockquote>
<p>在编译时,如果知道程序将放到内存中的哪个位置,编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址,将程序和数据装入内存。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/HWhnVYhHMYNa.png" alt="mark"></p>
<p><strong>绝对装入只适用于单道程序环境</strong>。</p>
<p>程序中使用的绝对地址,可在编译或汇编时给出,也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p>
</blockquote>
</li>
<li><p><strong>静态重定位</strong></p>
<blockquote>
<p>静态重定位:又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的,指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况,将装入模块装入到内存的适当位置。装入时对地址进行“<strong>重定位</strong>” ,将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/t09YVpGMlObb.png" alt="mark"></p>
<p>静态重定位的特点是在一个作业装入内存时,必须<strong>分配其要求的全部内存空间</strong>,如果没有足够的内存,就不能装入该作业。作业一旦进入内存后,<strong>在运行期间就不能再移动</strong>,也不能再申请内存空间。</p>
</blockquote>
</li>
<li><p><strong>动态重定位</strong></p>
<blockquote>
<p>动态重定位:又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后,并不会立即把逻辑地址转换为物理地址,而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器的支持</strong>。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/f456nJEC4yym.png" alt="mark"></p>
<p>并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行,然后在程序运行期间,根据需要动态申请分配内存;便于程序段的共享,可以向用户提供一个比存储空间大得多的地址空间</p>
</blockquote>
</li>
</ol>
<h3 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h3><ol>
<li><strong>静态链接</strong>:在程序运行之前,先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)之后不再拆开。</li>
<li><strong>装入时动态链接</strong>:将各目标模块装入内存时,边装入边链接的链接方式。</li>
<li><strong>运行时动态链接</strong>:在程序执行中需要该目标模块时,才对它进行链接。其优点是便于修改和更新,便于实现对目标模块的共享</li>
</ol>
<h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5><blockquote>
<p>在单一连续分配方式中,内存被分为<strong>系统区和用户区</strong>。系统区通常位于内存的低地址部分,用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中<strong>只能有一道用户程序</strong>,用户程序独占整个用户区”空间。</p>
<p><strong>优点</strong>:实现简单;<strong>无外部碎片</strong>;可以采用覆盖技术扩充内存;不一定需要采駛内存保护(eg:早期的PC操作系统MS-DOS)</p>
<p><strong>缺点</strong>:只能用于单用户、单任务的操作系统中;有内部碎片</p>
<blockquote>
<p>分配给某进程的内存区域中,如果有些部分没有用上,就是“内部碎片”</p>
</blockquote>
<p>存储器利用率极低。</p>
<img src="http://qiniuyun.lzfangwen.cn/blog/20200419/JvxJE8NPo7MN.png" alt="mark" style="zoom: 50%;">
</blockquote>
<h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><p>20世纪60年代出现了支持多道程序的系统,为了能在内存中装入多道程序,且这些程序之间又不会相互干扰,,于是将整个用户空间划分为若干个國定大小的分区,在每个分区中只装入一道作业,这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p>
<p>固定分区分配</p>
<ul>
<li><p>分区大小相等</p>
<blockquote>
<p>分区大小相等:缺乏灵活性,但是很适合用于用一台计算机控制多个相同对象的场合(比如:钢铁厂有n个相同的炼钢炉,就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)</p>
</blockquote>
</li>
<li><p>分区大小不等</p>
<blockquote>
<p>分区大小不等:增加了灵活性,可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区、适量中等分区、少量大分区)</p>
</blockquote>
</li>
</ul>
<blockquote>
<p> 操作系统需要建立一个数据结构–<strong>分区说明表</strong>,来实现各个分区的分配与回收。每个表项对应一个分区,通常按分区大小排列。每个表项包括对应分区的<strong>大小、起始地址、状态</strong>(是否已分配)。</p>
<p>用数据结构的数组(或链表)即可表示这个表</p>
<p>当某用户程序要装入内存时,由操作系统内核程序根据用户程序大小检索该表,从中找到一个能满足大小的、未分配的分区,将之分配给该程序,然后修改状态为“已分配”</p>
<p><strong>优点:实现简单,无外部碎片</strong>。</p>
</blockquote>
<h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><p><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>,而是在进程装入内存时,<strong>根据进程的大小动态地建立分区</strong>,并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p>
<p><strong>动态分区分配没有内部碎片,但是有外部碎片</strong>。</p>
<p><strong>内部碎片</strong>,分配给某进程的内存区域中,如果有些部分没有用上。</p>
<p><strong>外部碎片</strong>,是指内存中的某些空闲分区由于太小而难以利用。</p>
<p>如果内存中空闲空间的总和本来可以满足某进程的要求,但由于进程需要的是一整块连续的内存空间,因此这些“碎片”不能满足进程的需求。</p>
<p>可以通过<strong>紧凑(拼凑, Compaction)</strong>技术来解决外部碎片。</p>
<ul>
<li>两种数据结构</li>
</ul>
<ol>
<li><p><strong>空闲分区表</strong></p>
<blockquote>
<p>空闲分区表:每个空闲分区对应一个表项。表项中包含分区号分区大小、分区起始地址等信息<img src="http://qiniuyun.lzfangwen.cn/blog/20200419/uKFQ1hSoSnEU.png" alt="mark"></p>
</blockquote>
</li>
<li><p><strong>空闲分区链</strong></p>
<blockquote>
<p>空闲分区链:每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息<img src="http://qiniuyun.lzfangwen.cn/blog/20200419/emnC2xwL558e.png" alt="mark"></p>
</blockquote>
</li>
</ol>
<ul>
<li><strong>动态分区分配算法</strong></li>
</ul>
<ol>
<li><p><strong>首次适应算法</strong></p>
<blockquote>
<p>算法思想:每次都从低地址开始查找,找到第一个能满足大小的空闲分区。</p>
<p>如何实现:<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>) ,找到大小能满足要求的第一个空闲分区。</p>
</blockquote>
</li>
<li><p><strong>最佳适应算法</strong></p>
<blockquote>
<p>算法思想:由于动态分区分配是一种连续分配方式,为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间,可以尽可能多地留下大片的空闲区,即,优先使用更小的空闲区。</p>
<p>如何实现<strong>:空闲分区按容量递增次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>(或<strong>空闲分区表</strong>，找到大小能满足要求的第一个空闲分区。</p>
</blockquote>
</li>
<li><p><strong>最坏适应算法</strong></p>
<blockquote>
<p>又称<strong>最大适应算法</strong>(Largest Fit)</p>
<p>算法思想:为了解决最佳适应算法的问题–即留下太多难以利用的小碎片,可以在每次分配时优先使用最大的连续空闲区,这样分配后剩余的空闲区就不会太小,更方便使用。</p>
<p>如何实现:<strong>空闲分区按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链(或空闲分区表) ,找到大小能满足要求的第一个空闲分区。</p>
<p><strong>缺点</strong>:每次都选最大的分区进行分配,虽然可以让分配后留下的空闲区更大,更可用,但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达,就没有内存分区可用了。</p>
</blockquote>
</li>
<li><p><strong>邻近适应算法</strong></p>
<blockquote>
<p>AKA <strong>循环首次适应算法</strong></p>
<p>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区,而每次分配查找时,都要经过这些分区,因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索,就能解决上述问题。</p>
<p>如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时<strong>从上次查找结束的位置开始查找</strong>空闲分区链(或空闲分区表) ,找到大小能满足要求的第一个空闲分区。</p>
<p>优点</p>
<ul>
<li>首次适应算法每次都要从头查找,每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时,会更有可能用到低地址部分的小分区,也会更有可能把高地址部分的,大分区保留下来</li>
</ul>
<p>缺点</p>
<ul>
<li>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用,也就导致了高地址部分的大分区更可能被使用,划分为小分区,最后导致无大分区可用</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td>空闲分区以地址递增次序排序</td>
<td>综合看性能最好。算,法开销小,回收分区后一般不需要对空闲区队列重新排序</td>
<td></td>
</tr>
<tr>
<td>最佳适应</td>
<td>优先使用更小的分区,以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来,更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>,回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最坏适应</td>
<td>优先使用更大的分区,以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完,不禾于大进程;<strong>算法开销大</strong>(原因同上)</td>
</tr>
<tr>
<td>临近适应</td>
<td>由首次适应演变而来,每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址,递增次序排列(可排列成循环链表)</td>
<td>不用每次都从低地址的小分区开始检索。算法开销小(原因同次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><h5 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a><strong>基本分页存储管理</strong></h5><blockquote>
<p>将内存空间分为一个个<strong>大小相等的分区</strong>(比如:每个分区4KB) ,每个分区就是一个“<strong>页框</strong>” ,或称“<strong>页帧</strong>”、“<strong>内存块</strong>”、“<strong>物理块</strong>”。每个页框有一个编号,即“<strong>页框号</strong>” (或者“<strong>内存块号</strong>”、“<strong>页帧号</strong>”、“<strong>物理块号</strong>” )页框号<strong>从0开始</strong>。</p>
<p>将用户进程的地址空间也分为<strong>与页框大小相等</strong>的一个个区域,称为“<strong>页</strong>”或“<strong>页面</strong>” 。每个页面也有一个编号,即“页号”页号也是<strong>从0开始</strong>。</p>
<p>(注:进程的最后一个页面可能没有一个页框那么大。因此,<strong>页框不能太大,否则可能产生过大的内部碎片</strong>)</p>
<p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的每个页面分别放入一个页框中。也就是说,进程的<strong>页面与内存的页框有一一对应的关系</strong>。   </p>
</blockquote>
<h5 id="实现地址的转换"><a href="#实现地址的转换" class="headerlink" title="实现地址的转换"></a><strong>实现地址的转换</strong></h5><blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/0FzHRtjSfTto.png" alt="mark"></p>
<p>eg.    CPU执行指令1,需要访问逻辑地址为80的内存单元,如何转化为物理地址?</p>
<p>逻辑地址为80的内存单元:应该在<strong>1号页</strong>,该页在内存中的<strong>起始位置为450</strong>,逻辑地址为80的内存单元相对于该页的起始地址而言,“<strong>偏移量”应该是30</strong>    <strong>实际物理地址</strong>=450+ 30=480</p>
<ol>
<li><p>要算出逻辑地址对应的<strong>页号</strong></p>
</li>
<li><p>要知道该页号对应<strong>页面在内存中的起始地址</strong></p>
</li>
<li><p>要算出逻辑地址<strong>在页面内的“偏移量”</strong></p>
</li>
<li><p><strong>物理地址=页面始址+页内偏移量</strong></p>
<blockquote>
<p>页号=逻辑地址/页面长度(取除法的<strong>整数</strong>部分)</p>
<p>页内偏移量=逻辑地址%页面长度(取除法的<strong>余数</strong>部分)</p>
<p>页面在内存中的起始位置:操作系统需要用某种数据结构记录进程各个页面的起始位置。</p>
</blockquote>
<blockquote>
<p>页号=80/50=1</p>
<p>页内偏移量=80 % 50= 30</p>
<p>1号页在内存中存放的起始位置450</p>
</blockquote>
</li>
</ol>
</blockquote>
<h5 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a><strong>逻辑地址结构</strong></h5><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/VWp4DtKPHcYW.png" alt="mark"></p>
<p>地址结构包含两个部分:前一部分为页号,后一部分为页内偏移量w。在上图所示的例子中,地址长度为32位,其中0-11位为“页内偏移量”,或称“页内地址” ; 12~31位为“页号”</p>
<p><strong>如果有K位表示“页内偏移量” ,则说明该系统中一个页面的大小是$ 2^K $个内存单元如果有M位表示“页号” ,则说明在该系统中,一个进程最多允许有$ 2^M $个页面</strong></p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a><strong>页表</strong></h5><p>为了能知道进程的每个页面在内存中存放的位置,操作系统要为每个进程建立一张页表。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/nJYpkLCMmkvS.png" alt="mark"></p>
<ol>
<li><p>一个进程对应一张页表</p>
</li>
<li><p>进程的每一页对应一个页表项,每个页表项由“页号”和“块号”组成</p>
</li>
<li><p>页表记录进程页面和实际存放的内存块之间的对应关系</p>
</li>
<li><p>每个页表项的长度是相同的,<strong>页号是“隐含”的</strong></p>
</li>
</ol>
<h5 id="基本地址交换机构"><a href="#基本地址交换机构" class="headerlink" title="基本地址交换机构"></a>基本地址交换机构</h5><p>  <img src="http://qiniuyun.lzfangwen.cn/blog/20200421/Dncndo8PN9LG.png" alt="mark"></p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个<strong>页表寄存器(PTR)</strong> ,存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong>.进程未执行时,页表的始址和页表长度放在<strong>进程控制块(PCB)中</strong>,当进程被调度时,操作系统内核会把它们放到页表寄存器中。</p>
<p>注意:<strong>页面大小是2的整数幂</strong></p>
<p>设页面大小为L,逻辑地址A到物理地址E的变换过程如下:</p>
<ol>
<li>计算页号P和页内偏移量w (如果用十进制数手算,则P=A/L, W=A%L;但是在计算机实际运行时,逻辑地址结构是固定不变的,因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)</li>
<li>比较页号P和页表长度M,若P$\geq$M,则产生越界中断,否则继续执行。(注意:页号是从0开始的,而页表长度至少是1,因此<strong>P=M时也会越界</strong>)</li>
<li>页表中页号P对应的<strong>页表项地址=页表起始地址F+页号P×页表项长度,</strong>取出该页表项内容b,即为内存块号。(注意区分<strong>页表项长度、页表长度、页面大小的区别。页表长度</strong>指的是这个页表中总共有几个页表项,即总共有几个页;页表项长度指的是每个页表项占多大的存储空间;<strong>页面大小</strong>指的是一个页面占多大的存储空间）</li>
<li>计算E=b×L+w,用得到的物理地址E去访存。(如果内存块号、页面偏移量是用二进制表示的,那么把二者拼接起来就是最终的物理地址了)</li>
</ol>
<h5 id="具有快表的地址交换机构"><a href="#具有快表的地址交换机构" class="headerlink" title="具有快表的地址交换机构"></a>具有快表的地址交换机构</h5><p><strong>局部性原理</strong></p>
<blockquote>
<p><strong>时间局部性</strong>:如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p>
<p><strong>空间局部性</strong>:一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的）</p>
</blockquote>
<p><strong>什么是快表（TLB）</strong></p>
<blockquote>
<p>快表,又称<strong>联想寄存器(TLB)</strong> ,是一种<strong>访问速度比内存快很多</strong>的高速缓冲存储器,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应,内存中的页表常称为<strong>慢表</strong>。</p>
</blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/wq02ONIlqPtF.png" alt="mark"></p>
<p><strong>引入快表后，地址的变换过程</strong></p>
<ol>
<li><p>CPU给出逻辑地址, 由某个硬件算得页号、页内偏移量,将页号与快表中的所有页号进行比较。</p>
</li>
<li><p>如果找到匹配的页号,说明要访问的页表项在快表中有副本,则直接从中取出该页对应的内存块号,再将内存块号与页内偏移量拼接形成物理地址,最后,<strong>访问</strong>该物理地址对应的<strong>内存单元</strong>。因此,若<strong>快表命中</strong>,则访问某个逻辑地址仅需<strong>一次访存</strong>即可。</p>
</li>
<li><p>如果没有找到匹配的页号,则需要<strong>访问内存中的页表</strong>,找到对应页表项,得到页面存放的内存块号,再将内存块号与页内偏移量拼接形成物理地址,最后,访问该物理地址对应的内存单元。因此若<strong>快表未命中</strong>,则访问某个逻辑地址需要<strong>两次访存(</strong>注意:在找到页表项后,应同时将其存入快表,以便后面可能的再次访问。但若快表已满,则必须按照一定的算法对旧的页表项进行替换)</p>
<p>由于查询快表的速度比查询页表的速度快很多,因此只要快表命中,就可以节省很多时间。因为局部性原理,一般来说快表的命中率可以达到90%以上。</p>
<blockquote>
<p>eg.</p>
<p>某系统使用基本分页存储管理,并采用了具有快表的地址变换机构。访问一次快表耗时1us,访问一次内存耗时100us。若快表的命中率为90%,那么访问一个逻辑地址的平均耗时是多少?</p>
<p>(1+100) * 0.9 + (1+100+100)* 0.1=111 us</p>
<p>有的系统支持快表和慢表同时查找,如果是这样,平均耗时应该是(1+100) * 0.9 + (100+100) *0.1=110.9 us</p>
<p>若未采用快表机制,则访问一个逻辑地址需要100+100 =200us</p>
<p>显然,引入快表机制后,访问一个逻辑地址的速度快多了。</p>
</blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/hPVA2jcCLLXh.png" alt="mark"></p>
<h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><p>单级页表的问题</p>
<ul>
<li>页表必须连续存放,因此当页表很大时,需要占用很多个连续的页框。</li>
<li>没有必要让整个页表常驻内存,因为进程在一段时间内可能只需要访问某几个特定的页面。</li>
</ul>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/gVprkxsSFd7k.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/XTr6er5J0pMT.png" alt="mark"></p>
<p>若采用多级页表机制,则<strong>各级页表的大小不能超过一个页面</strong></p>
<blockquote>
<p>eg.:某系统按字节编址,采用40位逻辑地址,页面大小为4KB,页表项大小为4B,假设采用纯页式存储,则要采用()级页表,页内偏移量为()位?</p>
<p>页面大小=4KB=$2 ^{12}$B,按字节编址,因此页内偏移量为12位</p>
<p>页号=40-12=28位</p>
<p>页面大小=$2 ^{12}$B,页表项大小=4B,则每个页面可存放$2 ^{12}$/4=$2 ^{10}$个页表项因此各级页表最多包含$2 ^{10}$个页表项,需要10位二进制位才能映射到$2 ^{10}$个页表项,因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/C60oNnRiXfrS.png" alt="mark"></p>
</blockquote>
<p>两级页表的访存次数分析(假设没有快表机构),</p>
<ul>
<li>第一次访存:访问内存中的页目录表</li>
<li>第二次访存:访问内存中的二级页表</li>
<li>第三次访存:访问目标内存单元</li>
</ul>
<h5 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h5><h6 id="分段"><a href="#分段" class="headerlink" title="分段"></a><strong>分段</strong></h6><p>进程的地址空间:按照程序<strong>自身的逻辑</strong>关系<strong>划分为若干个段</strong>,每个段都有一个段名(在低级语言中,程序员使用段名来编程) ,<strong>每段从0开始编址</strong></p>
<p>内存分配规则:以段为单位进行分配<strong>,每个段在内存中占据连续空间,但各段之间可以不相邻</strong>。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/J9v6YEdtgc8L.png" alt="mark"></p>
<p>分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成。如</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/p1dDHMWD4a9H.png" alt="mark"></p>
<p>段号的位数决定了每个进程最多可以分几个段段内地址位数决定了每个段的最大长度是多少</p>
<p>在上述例子中,若系统是按字节寻址的,则段号占16位,因此在该系统中,每个进程最多有$2^{16}$= 64K个段</p>
<p>段内地址占16位,因此每个段的最大长度是$2^{16}$ = 64KB.</p>
<h6 id="段表"><a href="#段表" class="headerlink" title="段表"></a><strong>段表</strong></h6><p>问题:程序分多个段,各段离散地装入内存,为了保证程序能正常运行,就必须能从物理内存中,找到各个逻辑段的存放位置。为此,需为每个进程建立一张段映射表,简称“<strong>段表</strong>”</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/08QcoPEtVWPw.png" alt="mark"></p>
<ol>
<li>每个段对应一个段表项,其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。</li>
<li><strong>各个段表项的长度是相同的</strong>。例如:某系统按字节寻址,采用分段存储管理,逻辑地址结构为(段号16位,段内地址16位) ,因此用16位”即可表示最大段长。物理内存大小为4GB (可用32位表示整个物理内存地址空间)。因此,可以让每个段表项占16+32=48位,即6B,由于段表项长度相同,因此<strong>段号可以是隐含的,不占存储空间</strong>。若段表存放的起始地址为M,则K号段对应的段表项存放的地址为M+K6</li>
</ol>
<h6 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a><strong>地址变换</strong></h6><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/K5uOF5nJelLo.png" alt="mark"></p>
<h6 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a><strong>分段、分页管理的对比</strong></h6><blockquote>
<p><strong>页是信息的物理单位</strong>。分页的主要目的是为了实现离散分配,提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为,<strong>对用户是不可见的</strong>。</p>
<p><strong>段是信息的逻辑单位</strong>。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段<strong>对用户是可见的</strong>,用户编程时需要显式地给出段名。</p>
</blockquote>
<blockquote>
<p>页的大小固定且由系统决定。</p>
<p>段的长度却不固定,决定于用户编写的程序。</p>
</blockquote>
<blockquote>
<p>分页的用户进程地址空间是一维的,程序员只需给出一个记忆符即可表示一个地址。</p>
<p>分段的用户进程地址空间是二维的,程序员在标识一个地址时,既要给出段名,也要给出段内地址。</p>
</blockquote>
<blockquote>
<p><strong>分段比分页更容易实现信息的共享和保护</strong>。不能被修改的代码称为纯代码或可重入代码(不属于临界资源) ,这样的代码是可以共享的。可修改的代码是不能共享的</p>
</blockquote>
<p>访问一个逻辑地址需要几次访存?</p>
<blockquote>
<p>分页(单级页表) :第一次访存–查内存中的页表,第二次访存–访问目标内存单元。总共两次访存</p>
<p>分段:第一次访存–查内存中的段表,第二次访存–访问目标内存单元。总共两次访存</p>
</blockquote>
</li>
</ol>
<h5 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h5><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分页管理</td>
<td>内部空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td>
<td>不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>很方便按照逻辑模块实现信息的共享和保护</td>
<td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片<a href="分段管理中产生的外部碎片也可以用“紧凑”来解决，只是需要付出较大的时间代价">^1</a></td>
</tr>
</tbody></table>
<h6 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段+分页=段页式管理"></a>分段+分页=段页式管理</h6><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/1n4urzBOQxYi.png" alt="mark"></p>
<p>将进程按逻辑模块分段,再将各段分页(如每页面4KB)</p>
<p>再将内存空间分为大小相同的内存块/页框/页帧/物理块进程前将各页面分别装入各内存块中</p>
<h6 id="段页式管理的逻辑地址"><a href="#段页式管理的逻辑地址" class="headerlink" title="段页式管理的逻辑地址"></a>段页式管理的逻辑地址</h6><p>分段系统的逻辑地址结构由段号和段内地址(段内偏移量)组成。如:</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/rOdbqmrsqdk6.png" alt="mark"></p>
<p>段页式系统的逻辑地址结构由段号、页号、页内地址(页内偏移量)组成。如:</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/BpN1H9vT4YDw.png" alt="mark"></p>
<p><strong>段号的位数决定了每个进程最多可以分几个段</strong></p>
<p><strong>页号位数决定了每个段最大有多少页</strong></p>
<p><strong>页内偏移量决定了页面大小、内存块大小是多少</strong></p>
<blockquote>
<p>在上述例子中,若系统是按字节寻址的,则段号占16位,因此在该系统中,每个进程最多有216=64K个段页号占4位,因此每个段最多有$2^{16}$页</p>
<p>页内偏移量占12位,因此每个页面每个内存块大小为2= 4096=4KB</p>
</blockquote>
<p>分段”对用户是见序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。</p>
<p>因此<strong>段页式管理的地址结构是二维的</strong>。</p>
<h6 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h6><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/Vm84OP0K9Ovp.png" alt="mark"></p>
<p>每个段对应一个段表项,每个段表项由段号、页表长度、页表存放块号(页表起始地址)<strong>组成</strong>。每个<strong>段表项长度相等,段号是隐含的</strong>。每个页面对应一个页表项,每个页表项由页争、页面存放的内存块号组成。每个页表项长度相等,页号是隐含的。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200420/zPDOShGp2BLf.png" alt="mark"></p>
<p>也可引入快表机构，用段号和页号作为查询快表的关键字。若快表命中仅需一次访存</p>
<h3 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/BHoS2vTtMLAG.png" alt="mark"></p>
<p>必须由程序员声明覆盖结构,操作系统完成自动覆盖。</p>
<p>缺点:对用户不透明,增加了用户编程负担。覆盖技术只用于早期的操作系统中,现在已成为历史。</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换(对换)技术的设计思想:内存空间紧张时,系统将内存中某些进程暂时换出外存,把外存中·某些已具备运行条件的进程<strong>换入</strong>内存(进程在内存与磁盘间动态调度)</p>
<p>暂时换出外存等待的进程状态为<strong>挂起状态(挂起态, suspend)</strong></p>
<p>挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态   </p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/4shgMvrJHgbi.png" alt="mark"></p>
<blockquote>
<img src="http://qiniuyun.lzfangwen.cn/blog/20200419/YIBfEeES4ReJ.png" alt="mark" style="zoom: 67%;">

<ol>
<li>具有对换功能的操作系统中,通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件,<strong>主要追求存储空间的利用率</strong>,因此对文件区空间的管理<strong>采用离散分配方式</strong>;对换区空间只占磁盘空间的小部分,<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度,因此对换区空间的管理<strong>主要追求换入换出速度</strong>,因此通常对换区<strong>采用连续分配方式</strong>(学过文件管理章节后即可理解)。总之<strong>对换区的I/O 速度比文件区的更快</strong>。</li>
<li>交换通常在许多进程运行且内存吃紧时进行,而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页,就说明内存紧张,此时可以换出一些进程;如果缺页率明显下降,就可以暂停换出。</li>
<li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出,有的系统还会考虑进程在内存的驻留时间….</li>
<li>注意：PCB会常驻内存，不会被换出外存 </li>
</ol>
</blockquote>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了使编程更方便,程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>(这个过程称为<strong>地址重定位</strong>)应该由操作系统负责,这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存保护可采取两种方法:</p>
<ol>
<li>在CPU中设置一对上、下限寄存器,存放进程的上、下限地址。进程的指令要访问某个地址时, CPU检查是否越界。</li>
<li>采用<strong>重定位寄存器</strong>(又称<strong>基址寄存器</strong>)和<strong>界地址寄存器</strong>(又称<strong>限长寄存器</strong>)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li>
</ol>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200419/PUqWKAzn5IH5.png" alt="mark"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理及应用-学习笔记1</title>
    <url>/lzfangwen.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>﻿## DBMS（数据库系统）</p>
<h4 id="DBMS的主要功能"><a href="#DBMS的主要功能" class="headerlink" title="DBMS的主要功能"></a>DBMS的主要功能</h4><p>1.数据定义功能<br>2.数据操作功能<br>3.数据库运行管理功能<br>4.数据库的建立和维护功能</p>
<a id="more"></a>

<h4 id="DBMS的组成"><a href="#DBMS的组成" class="headerlink" title="DBMS的组成"></a>DBMS的组成</h4><p>1.语言编译处理程序<br>2.系统运行控制程序<br>3.系统建立，维护程序<br>4.数字字典</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型 是一种表示数据及其联系的模型,是对现实世界数据特征与联系的抽象反映。<br><img src="https://img-blog.csdnimg.cn/20200313150028827.png" alt="在这里插入图片描述"><br>根据数据模型应用的不同目的，可以划分为两类，它们分别属于不同的层次。<br>第一类是概念模型，第二类是逻辑模型和物理模型</p>
<ul>
<li><strong>概念模型</strong>(或称信息模型) :它是按用户的观点来对数据和信息建模,即用于信息世界的建模,所建立的是属于信息世界的模型。主要用于数据库的设计。</li>
<li><strong>逻辑模型</strong>(或称结构数据模型) :主要包括网状模型、层次模型、关系模型等,是按计算机系统的观点对数据建模”,所建立的是属于机器世界的模型,主要用于DBMS的实现。后面主要讨论这类数据模型。</li>
<li><strong>物理模型</strong>:是对数据最低层的抽象,是面向计算机物理表示的模型,它描述数据在系统内部的表示方式和存取方法,它不但与具体的DBMS有而且还与操作系统和硬件有关。每一种逻辑模型在实现时都有相对应的物理数据模型。<br><img src="https://img-blog.csdnimg.cn/20200313150529190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><strong>实体间的联系</strong><br> 1：1<br> 1：n<br> n：m<br><strong>实体-联系表示法（E-R方法）</strong><br>在E-R图中实体用方框表示;联系用菱形表示,并且用边将其与有关的实体连接起来,并在边上标上联系的类型;属性用椭圆表示,并且用边将其与相应的实体连接起来。对于有些联系,其自身也会有某些属性,同实体与属性的连接类似,将联系与其属性连接起来。<br>eg：<img src="https://img-blog.csdnimg.cn/20200313151618781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="DMBS支持的数据模型"><a href="#DMBS支持的数据模型" class="headerlink" title="DMBS支持的数据模型"></a>DMBS支持的数据模型</h2><p><strong>数据模型组成的要素</strong></p>
<ul>
<li><strong>数据结构</strong><br>数据结构是刻画一个数据模型性质最重要的方面,通常按数据组织结构的类型来命名数据模型,如层次结构、网状图结构和关系结构的数据模型分别命名为层次模型、网状模型和关系模型。<br>数据结构是对系统静态特性的描述,其描述的内容有两类:数据的描述和数据之间联系的描述。</li>
<li><strong>数据操作</strong><br>数据操作是对系统动态特性的描述,是数据库中的各种对象的实例(值)允许执行的操作的集合。<br>主要有检索和更新(插入、删除、修改)两类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则、实现操作的语言。</li>
<li><strong>数据约束</strong><br>数据的完整性约束条件是一组完整性规则的集合,给出数据及其联系所具有的制约、依赖和存储规则,用于限定数据库的状态和状态变化,保证数据库中的数据的正确、有效、完全和相容。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据库原理及应用</category>
      </categories>
      <tags>
        <tag>SQLserver</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记2</title>
    <url>/lzfangwen.github.io/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>﻿<img src="https://img-blog.csdnimg.cn/20200313111304663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<p>冯·诺伊曼计算机的特点<br>1.计算机由五大部件<br>2.指令和数据以同等地位存于存储器，可按地址寻访<br>3.指令和数据用二进制表示<br>4.指令由操作码和地址码组成<br>5.存储程序<br>6.以运算器为核心</p>
<p><img src="https://img-blog.csdnimg.cn/20200313111342721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020031311145292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200316092536882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200313112917893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200313112951742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020031311384993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200313114018661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记1</title>
    <url>/lzfangwen.github.io/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><strong>B站 王道考研视频 学习笔记 纯粹自己整理方便复习使用 侵删</strong></p>
<p>﻿# 第一章 计算机系统简介</p>
<h2 id="软硬件"><a href="#软硬件" class="headerlink" title="软硬件"></a>软硬件<a id="more"></a><img src="https://img-blog.csdnimg.cn/20200313110251157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt=""></h2><p><img src="https://img-blog.csdnimg.cn/20200313110314482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200313110725516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200313110746978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://www.icourse163.org/spoc/learn/HHIT-1451455173?tid=1451908450#/learn/content?type=detail&amp;id=1220058249&amp;cid=1228881649" target="_blank" rel="noopener">慕课链接</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-学习笔记9</title>
    <url>/lzfangwen.github.io/2020/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09/</url>
    <content><![CDATA[<h1 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h1><a id="more"></a>

<h2 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h2><p>特征</p>
<ul>
<li><strong>一次性</strong>:<strong>作业必须一次性全部装入内存后才能开始运行</strong>。这会造成两个问题:<ol>
<li>作业很大时,不能全部装入内存,导致大作业无法运行; </li>
<li>当大量作业要求运行时,由于内存无法容纳所有作业,因此只有少量作业能运行,导致<strong>多道程序并发度下降</strong>。</li>
</ol>
</li>
<li><strong>驻留性:</strong>一旦作业被装入内存,就会<strong>一直驻留在内存中</strong>,直至作业运行结束。事实上,在一个时间段内,只需要访问作业的一小部分数据即可正常运行,这就导致了内存中会驻留大量的、暂时用不到的数据,浪费了宝贵的内存资源。</li>
</ul>
<h2 id="程序运行存在的局部性"><a href="#程序运行存在的局部性" class="headerlink" title="程序运行存在的局部性"></a>程序运行存在的局部性</h2><h3 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h3><p>如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p>
<h3 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h3><p>一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的,并且程序的指令也是顺序地在内存中存放的)</p>
<h3 id="高速缓存技术"><a href="#高速缓存技术" class="headerlink" title="高速缓存技术"></a>高速缓存技术</h3><p>高速缓冲技术的思想:将近期会频繁访问到的数据放到更高速的存储器中,暂时用不到的数放在更低速存储器</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/ML1AYnbKfkQI.png" alt="mark"></p>
<p>像是快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</p>
<h2 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h2><p>基于局部性原理,在程序装入时,可以将程序中<strong>很快会用到的部分装入内存,暂时用不到的部分留在外存,</strong>就可以让程序开始执行。</p>
<p>在程序执行过程中,当所访问的<strong>信息不在内存时**</strong>,由操作系统负责将所需信息从外存调入内存**,然后继续执行程序。</p>
<p>若内存空间不够,由<strong>操作系统负责将内存中暂时用不到的信息换出到外存</strong>。</p>
<p>在操作系统的管理下,在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p>
<blockquote>
<p>操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充。</p>
</blockquote>
<p><strong>易混知识点</strong>:</p>
<blockquote>
<p>虚拟内存的<strong>最大容量</strong>是由计算机的地址结构(CPU寻址范围)确定的</p>
<p>虚拟内存的<strong>实际容量</strong>=min (内存和外存容量之和, CPU寻址范围）</p>
</blockquote>
<p>eg.</p>
<blockquote>
<p>某计算机地址结构为32位,按字节编址,内存大小为512MB,外存大小为2GB</p>
<p>则虚拟内存的<strong>最大容量</strong>为2^32^B=4GB</p>
<p>虚拟内存的<strong>实际容量</strong>=min(2^32^,512MB+2GB)=2GB+512MB</p>
</blockquote>
<h3 id="虚拟内存的三个特征"><a href="#虚拟内存的三个特征" class="headerlink" title="虚拟内存的三个特征"></a>虚拟内存的三个特征</h3><ul>
<li><strong>多次性</strong> : 无需在作业运行时一次性全部装入内存,而是允许被分成多次调入内存。</li>
<li><strong>对换性</strong> : 在作业运行时无需一直常驻内存,而是允许在作业运行过程中,将作业换入、换出。</li>
<li><strong>虚拟性</strong> : 从逻辑上扩充了内存的容量,使用户看到的内存容量,远大于实际的容量。</li>
</ul>
<h2 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h2><p>虚拟内存技术,允许一个作业分多次调入内存。如果采用连续分配方式,会不方便实现。因此虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式基础上。</p>
<p> <img src="http://qiniuyun.lzfangwen.cn/blog/20200428/HHLs1USWs7pE.png" alt="mark"></p>
<p>主要区别:</p>
<ul>
<li><p>在程序执行过程中,当所<strong>访问的信息不在内存时,由操作系统负责将所需信息从外存调入内存,</strong>然后继续执行程序。</p>
<blockquote>
<p>操作系统要提供请求调页（或请求调段）功能</p>
</blockquote>
</li>
<li><p>若<strong>内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存</strong></p>
<blockquote>
<p>操作系统要提供页面置换（或段置换）的功能</p>
</blockquote>
</li>
</ul>
<h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3><p><strong>请求分页</strong>存储管理与<strong>基本分页</strong>存储管理的主要区别:</p>
<ul>
<li>在程序执行过程中,当所访问的信息不在内存时,由操作系统负责将所需信息从外存调入内存,然后继续执行程序。</li>
<li>内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存</li>
</ul>
<h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/efv3BshUgoXN.png" alt="mark"></p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>假设此时要访问逻辑地址=(页号,页内偏移量) = (0, 1024)</p>
<blockquote>
<p>在请求分页系统中,每当要访问的<strong>页面不在内存</strong>时,便<strong>产生一个缺页中断</strong>,然后由操作系统的<strong>缺页中断处理程序处理中断</strong>。此时<strong>缺页的进程阻塞,</strong>放入阻塞队列,调页<strong>完成后再将其唤醒</strong>,放回就绪队列。</p>
<p>如果内存中<strong>有空闲块</strong>,则为进程<strong>分配一个空闲块</strong>,将所缺页面装入该块,并修改页表中相应的页表项。</p>
<p>如果内存中<strong>没有空闲块,</strong>则由<strong>页面置换算法选择一个页面淘汰</strong>,若该页面在内存期间<strong>被修改过</strong>,则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</p>
</blockquote>
<blockquote>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的,因此属于<strong>内中断</strong></p>
</blockquote>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的,因此<strong>属于内中断</strong></p>
<p><strong>一条指令</strong>在执行期间,<strong>可能产生多次缺页中断</strong>。(如: copy A to B,即将逻辑地址A中的数据复制到逻辑地址B,而A、B属于不同的页面,则有可能产生两次中断)</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/APYoWjBbQvcx.png" alt="mark"></p>
<p>相较于基本分页管理的不同</p>
<ol>
<li>请求调页 ( 查到页表项时进行判断 ) </li>
<li>页面置换 ( 需要调入页面 , 但没有空闲内存块时进行)</li>
<li>需要修改请求 页表中新增的项</li>
</ol>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/oNVJF5yuqa6n.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/drt2B9t9k7Sj.png" alt="mark"></p>
<p>补充细节:</p>
<ol>
<li>只有“写指令”才需要修改“修改位”。并且,一般来说只需修改快表中的数据,只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>
<li>和普通的中断处理一样,缺页中断处理依然需要保留CPU现场。</li>
<li>需要用某种“<strong>页面置换算法</strong>”来决定一个换出页面(下节内容)</li>
<li>换入/换出页面都需要启动慢速的 I/O 操作,可见,如果换入/换出太频繁,会有很大的开销。</li>
<li>页面调入内存后,需要修改慢表,同时也需要将表项复制到快表中。</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的置换算法应该<strong>追求更少的缺页率。</strong></p>
<h3 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h3><p>最佳置换算法(OPT, Optimal) :每次<strong>选择淘汰的页面将是以后永不使用,或者在最长时间内不再被访问的页面,这样可以保证最低的缺页率。</strong></p>
<p>例:假设系统为某进程分配了三个内存块,并考虑到有一下页面号引用串(会依次访问这些页面) :7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7,0, 1</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/TXVymO3QxBCX.png" alt="mark"></p>
<h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><p>先进先出置换算法(FIFO) :每次<strong>选择淘汰的页面是最早进入内存的页面</strong></p>
<p>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列,需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p>例:假设系统为某进程分配了三个内存块,并考虑到有以下页面号引用串:3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/cAOh2BA3C9Uh.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/n5RzuiVNEtQB.png" alt="mark"></p>
<p><strong>Belady异常</strong>–当为进程分配的物理块数增大时,缺页次数不减反增的异常现象。</p>
<p><strong>只有FIFO算法会产生Belady异常</strong>。另外, FIFO算法虽然实现简单,但是该算法与进程实际运行时的规律不适应,因为先进入的页面也有可能最经常被访问。因此,<strong>算法性能差</strong></p>
<h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><p>最近最久未使用置换算法(LRU, least recently used) :每次淘汰的页面是最近最久未使用的页面</p>
<p>实现方法:赋予每个页面对应的页表项中,用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p>例:假设系统为某进程分配了四个内存块,并考虑到有以下页面号引用串:</p>
<p>​                                        1, 8, 1, 7, 8, 2, 7, 2, 1,8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/1YiagqDLhsOG.png" alt="mark"></p>
<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号，在<strong>逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</strong></p>
<p><strong>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。</strong></p>
<h3 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h3><p><strong>时钟置换算法</strong>是一种性能和开销较均衡的算法,又称<strong>CLOCK算法</strong>,或<strong>最近未用算法(NRU</strong>, Not Recently Used)</p>
<p>简单的CLOCK算法实现方法:为每个页面设置一个<strong>访问位</strong>,再将内存中的页面都通过链接指针<strong>链接成个循环队列</strong>。当某页被访问时,其访问位置为1。当需要淘汰一个页面时,只需检查页的访问位。如果是0,就选择该页换出;如果是1,则将它置为0,暂不换出,继续检查下一个页面,若第一轮扫描中所有页面都是1,则将这些页面的访问位依次置为0后,再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面,因此<strong>简单的CLOCK算法</strong>选择一个淘汰页面<strong>最多会经过两轮扫描</strong>)</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200428/WpadywOUV12q.png" alt="mark"></p>
<p>例:假设系统为某进程分配了五个内存块,并考虑到有以下页面号引用串1, 3, 4, 2, 5, 6, 3, 4, 7</p>
<h3 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上,如果被淘汰的页面没有被修改过,就不需要执行10操作写回外存。只有被淘汰的页面被修改过时,才需要写回外存。</p>
<p>因此,除了考虑一个页面最近有没有被访问过之外,操作系统还应考虑页面有没有被修改过。在其他条件都相同时,应优先淘汰没有修改过的页面,避免/0操作。这就是改进型的时钟置换算法的思想。修改位-0,表示页面没有被修改过;修改位=1,表示页面被修改过。</p>
<p>为方便讨论,用(访问位,修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过,且被修改过。</p>
<p>算法规则:将所有可能被置换的页面排成一个循环队列</p>
<ul>
<li><p>第一轮:从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位</p>
<blockquote>
<p>最近没访问，且没修改的页面</p>
</blockquote>
</li>
<li><p>第二轮:若第一轮扫描失败,则重新扫描,查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0</p>
<blockquote>
<p>最近没访问，但修改过的页面</p>
</blockquote>
</li>
<li><p>第三轮:若第二轮扫描失败,则重新扫描,查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位</p>
<blockquote>
<p>最近访问过，但没修改的页面</p>
</blockquote>
</li>
<li><p>第四轮:若第三轮扫描失败,则重新扫描,查找第一个(0,1)的帧用于替换。</p>
<blockquote>
<p>最近访问过，且修改过的页面</p>
</blockquote>
</li>
</ul>
<p>由于第二轮已将所有帧的访问位设为0,因此经过第三轮、第四轮扫描定会有一个帧被选中,因此<strong>改进型CLOCK置换算法</strong>选择一个淘汰页面<strong>最多会进行四轮扫描</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>算法规则</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>OPT</td>
<td>优先淘汰最长时间内不会被访问的页面</td>
<td>缺页率最小,性能最好;但无法实现</td>
</tr>
<tr>
<td>FIFO</td>
<td>优先淘汰最先进入内存的页面</td>
<td>实现简单;但性能很差,可能出现Belady异常</td>
</tr>
<tr>
<td>LRU</td>
<td>优先淘汰最近最久没访问的页面</td>
<td>性能很好;但需要硬件支持,算法开销大</td>
</tr>
<tr>
<td>CLOCK(NRU)</td>
<td>循环扫描各页面 第一轮淘汰访问位 = 0 的，并将扫描过的页面访问位改为 1 。若第一轮没选中，则进行第二轮扫描</td>
<td>实现简单,算法开销小;但未考虑页面是否被修改过。</td>
</tr>
<tr>
<td>改进型CLOCK(改进型NRU)</td>
<td>若用(访问位,修改位)的形式表述,则第一轮:淘汰(0, 0)第二轮:淘汰(0,1) ,并将扫描过的页面访问位都置为0第三轮:淘汰(0, 0)第四轮:淘汰(0, 1)</td>
<td>算法开销较小,性能也不错</td>
</tr>
</tbody></table>
<h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><h3 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h3><p>指请求分页存储管理中给进程分配的物理块集合。</p>
<p>在采用了虚拟存储技术的系统中,驻留集大小一般小于进程的总大小。若驻留集太小,会导致缺页频繁,系统要花大量的时间来处理缺页,实际用于进程推进的时间很少;驻留集太大,又会导致多道程序并发度下降,资源利用率降低。所以应该选择一个合适的驻留集大小。</p>
<p><strong>固定分配</strong>:操作系统为每个进程分配一组固定数目的物理块,在进程运行期间不再改变。即,驻留集大小不变</p>
<p><strong>可变分配</strong>:先为每个进程分配一定数目的物理块,在进程运行期间,可根据情况做适当的增加或减少。即,驻留集大小可变</p>
<p><strong>局部置换</strong>:发生缺页时只能选进程自己的物理块进行置换。</p>
<p><strong>全局置换</strong>:可以将操作系统保留的空闲物理块分配给缺页进程,也可以将别的进程持有的物理块置换到外存,再分配给缺页进程。</p>
<table>
<thead>
<tr>
<th></th>
<th>局部置换</th>
<th>全局置换</th>
</tr>
</thead>
<tbody><tr>
<td>固定分配</td>
<td>√</td>
<td>—</td>
</tr>
<tr>
<td>可变分配</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配。</p>
<h3 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h3><p><strong>固定分配局部置换</strong>:</p>
<blockquote>
<p>系统为每个进程分配一定数量的物理块,在整个运行期间都不改变。若进程在运行中发生缺页,则只能从该进程在内存中的页面中选出一页换出,然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数),</p>
</blockquote>
<p><strong>可变分配全局置换</strong>:</p>
<blockquote>
<p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时,从空闲物理块中取出一块分配给该进程;若已无空闲物理块,则可选择个<strong>未锁定</strong>的页面换出外存,再将该物理块分配给缺页的进程。采用这种策略时,<strong>只要某进程发生缺页</strong>,<strong>都将获得新的物理块,</strong>仅当空闲物理块用完时,系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页,因此这个<strong>被选中的进程拥有的物理块会减少,缺页率会增加。</strong></p>
</blockquote>
<p><strong>可变分配局部置换</strong></p>
<blockquote>
<p>可变分配局部置换:刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时,只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页,系统会为该进程多分配几个物理块,直至该进程缺页率趋势适当程度;反之,如果进程在运行中缺页率特别低,则可适当减少分配给该进程的物理块。</p>
</blockquote>
<p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块</p>
<p>可变分配<strong>局部</strong>置换：要根据发生<strong>缺页的频率</strong>来动态的地增加或减少进程的物理块</p>
<h3 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h3><ol>
<li>预调页策略:根据局部性原理（主要是指空间局部性）,一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过,则又是低效的。因此可以预测不久之后可能访问到的页面,将它们预先调入内存,但目前预测成功率只有50%左右。故这种策略<strong>主要用于进程的首次调入</strong>,由程序员指出应该先调入哪些部分。请求调页策略:进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到,但由于每次只能调入一页,而每次调页都要磁盘1/0操作,因此/0开销较大。</li>
<li>请求调页策略:进程<strong>在运行期间发现缺页时才将所缺页面调入内存</strong>。由这种策略调入的页面一定会被访问到,但由于每次只能调入一页,而每次调页都要磁盘1/0操作,因此/0开销较大。</li>
</ol>
<h3 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h3><ol>
<li><p>系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行,这样可以保证页面的调入、调出速度很快。在进程运行前,需将进程相关的数据从文件区复制到对换区。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200429/Apj0CS3kzO3Y.png" alt="mark"></p>
</li>
<li><p>系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入,由于这些页面不会被修改,因此换出时不必写回磁盘,下次需要时再从文件区调入即可。对于可能被修改的部分,换出时需写回磁盘对换区,下次需要时再从对换区调入。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200429/gMArs2MMuA9m.png" alt="mark"></p>
</li>
<li><p>UNIX方式:运行之前进程有关的数据全部放在文件区,故未使用过的页面,都可从文件区调入。若被使用过的页面需要换出,则写回对换区,下次需要时从对换区调入。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200429/qFlQI0VYYKEe.png" alt="mark"></p>
</li>
</ol>
<h3 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h3><p>刚刚换出的页面马上又要换入内存,刚刚换入的页面马上又要换出外存,这种频繁的页面调度行为称为<strong>抖动</strong>,或颠簸。产生抖动的<strong>主要原因</strong>是进程频繁访问的页面数目高于可用的物理块数(<strong>分配给进程的物理块不够)</strong></p>
<p>为了研究应该为每个进程分配多少个物理块，Denning提出了 “ 工作集 ” 的概念。</p>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留集:指请求分页存储管理中给进程分配的内存块的集合。</p>
<p> 工作集:指在某段时间间隔里,进程实际访问页面的集合。操作系统会根据“窗口尺寸”来算出工作集。例:某进程的页面访问序列如下,窗口尺寸为4,各时刻的工作集为?</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200429/UkwidaS5Anzn.png" alt="mark"></p>
<p><strong>工作集大小</strong>可能小于窗口尺寸,实际应用中,操作系统可以统计进程的工作集大小,根据工作集大小哈进程分配若干内存块。如:窗口尺寸为5,经过一段时间的监测发现某进程的工作集最大为3,那么说明该进程有很好的局部性,可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说,<strong>驻留集大小不能小于工作集大小,否则进程运行过程中将频繁缺页</strong>。</p>
<p>拓展:基于局部性原理可知,进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此,可以根据进程近期访问的页面集合(工作集)来设计一种页面置换算法–选择一个不在工作集中的页面进行淘汰。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理-汉明码</title>
    <url>/lzfangwen.github.io/2020/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%B1%89%E6%98%8E%E7%A0%81/</url>
    <content><![CDATA[<p><strong>自己的理解 帮助自己复习用的 写的可能会有错误</strong></p>
<h2 id="汉明码-Hamming-Code"><a href="#汉明码-Hamming-Code" class="headerlink" title="汉明码(Hamming Code )"></a>汉明码(Hamming Code )</h2><blockquote>
<p>汉明码（Hamming Code），是在电信领域的一种线性调试码，以发明者理查德·卫斯里·汉明的名字命名。汉明码在传输的消息流中插入验证码，当计算机存储或移动数据时，可能会产生数据位错误，以侦测并更正单一比特错误。由于汉明编码简单，它们被广泛应用于内存（RAM）。——百度百科</p>
</blockquote>
<a id="more"></a>

<p>说人话 就是 我想发送一串二进制数据 例如 10010<br>但我又怕发送过程中出现意外就用检测码的形式保证不会出错，出错了也可以通过检测码查出哪位出错了因为二进制只有01，错了就能改正。</p>
<h2 id="发送biubiubiu"><a href="#发送biubiubiu" class="headerlink" title="发送biubiubiu"></a>发送biubiubiu</h2><p>我想发 10010<br>首先 根据公式<br>$$<br>2^{k}&gt;=n+k+1<br>$$<br> n位二进制位数 k位检测位数<br>算出k最小为4<br>也就是5位的二进制数据10010要插入4位检测码<br>但插入并不是直接放在数据最前或是最后<br>4位检测码是按照<br>$$<br>2^{i}<br>$$<br>位放入二进制数据中</p>
<table>
<thead>
<tr>
<th align="center">二进制数据序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">序号用二进制表示</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
</tr>
<tr>
<td align="center">数据串</td>
<td>C1</td>
<td>C2</td>
<td>1</td>
<td>C4</td>
<td>0</td>
</tr>
</tbody></table>
<p>根据序号的二进制进行分组<br>满足 XXX1 的位第一组     </p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>1</th>
<th>3</th>
<th>5</th>
<th>7</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据串</td>
<td>C1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>满足 XX1X 的为第二组 </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>2</th>
<th>3</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>C2</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>满足 X1XX 的为第三组    </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>C4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>满足1XXX的为第四组</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>C8</td>
<td>0</td>
</tr>
</tbody></table>
<p>Ci为第几位检测码 可以发现每组数据串都有一位检测码 分别对其进行偶校验 就可以得出检测码了 从而得到最终的汉明码<br>第一组 C1为0<br>第二组 C2为0<br>第三组 C3为1<br>第四组 C4为0<br>所以最后的海明码为 001100100 然后就可以biubiubiu 发过去了</p>
<h2 id="接收duangduangduang"><a href="#接收duangduangduang" class="headerlink" title="接收duangduangduang"></a>接收duangduangduang</h2><p>接收一串海明码怎么查错及提取有效数据嘞<br>还是以上面发送的为例 001 100 100在发送过程中第6位错了变成了001 101 100<br><del>看我操作就行了</del><br>接收duangduangduang<br>分组进行偶校验 满足给0 不满足给1</p>
<table>
<thead>
<tr>
<th>二进制数据序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>序号用二进制表示</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
</tr>
<tr>
<td>数据串</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>满足 XXX1 的位第一组     满足偶校验 给0</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>1</th>
<th>3</th>
<th>5</th>
<th>7</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>满足 XX1X 的为第二组     不满足偶校验 给1</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>2</th>
<th>3</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>满足 X1XX 的为第三组    不满足偶校验 给1</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>满足1XXX的为第四组     满足偶校验 给0</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>按照组数从大到小列出为 0110 <del>卧槽</del> 正好就是6的二进制表示<br>就是第6位错了 改过来就得了 001 100 100 ✔<br>有效信息的话就是 去掉第1，2，4，8位的检验码<br>为 10010√<br>呐呐呐 就结束了 </p>
<h2 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h2><p>添加一位检测位，使得二进制数据中满足奇偶原则</p>
<p><strong>配偶原则</strong> 就是检测二进制数据中‘1’的个数如果为奇数个，检测位就为‘1’使得满足二进制数据中‘1’的个数满足偶数个，如果个数为偶数，检测位则为‘0’ 这就是配偶原则也叫<strong>偶校验</strong></p>
<p><strong>配奇原则</strong>就是检测二进制数据中‘1’的个数 如果为奇数，检测位为‘0’，如果为偶数，检测位为‘1’以此满足配奇数原则，也叫<strong>奇校验</strong></p>
<h2 id="为啥子呢"><a href="#为啥子呢" class="headerlink" title="为啥子呢"></a>为啥子呢</h2><p>会做了  我们来搞搞原理<br><img src="https://img-blog.csdnimg.cn/20200324094401246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一串数据 1 2 3 4 5 6 7<br>分为三组<br>第一组 1 2 3 4<br>第二组 2 3 5 6<br>第三组 3 4 6 7<br>7个数中其中有一个是错的<br>我们还可以知道三个组有哪些是全对的 那些是错的<br>我们就能判断出 哪个数错了 神不神奇wow<br>eg.<br>    第一组错了 ，第二三组对了 看图 就能知道 1是错的<br>      第一二错了 第三组对了       看图得知 2是错的</p>
<p>简单的原理就是这个原理<br>我也说不清<br>自己体会<br>那就这样吧<br>写博客号累 写一上午了<br><del>我要去打csgo了</del><br>我要继续去学习了</p>
<h2 id="其他一些想说的"><a href="#其他一些想说的" class="headerlink" title="其他一些想说的"></a>其他一些想说的</h2><p>==汉明码 默认只错一位==<br>汉明码 顺序的话可以从右向左 也就是可以</p>
<table>
<thead>
<tr>
<th>二进制数据序号</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>数据串</td>
<td></td>
<td>C4</td>
<td></td>
<td></td>
<td></td>
<td>C3</td>
<td></td>
<td>C2</td>
<td>C1</td>
</tr>
</tbody></table>
<p>就是序号顺序和检测码顺序得保持一致<br>而且写汉明码和姐汉明码方向应该一致（应该是对的我验证了一下<del>就因为我看的一个教程 方向错了 我做的作业全错 呜呜呜</del>  ）<br>不过默认从左向右 <del>别整那些骚的了</del>  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>Hamming Code</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 学习笔记1</title>
    <url>/lzfangwen.github.io/2020/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><strong>B站 王道考研视频 学习笔记 纯粹自己整理方便复习使用 侵删</strong></p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><img src="https://img-blog.csdnimg.cn/20200318084558533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p><img src="https://img-blog.csdnimg.cn/20200318085732967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p><img src="https://img-blog.csdnimg.cn/20200318092520956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="https://img-blog.csdnimg.cn/20200318090511517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="https://img-blog.csdnimg.cn/20200318090520447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img src="https://img-blog.csdnimg.cn/20200318091719994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><img src="https://img-blog.csdnimg.cn/20200318091947775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><p><img src="https://img-blog.csdnimg.cn/20200318092228234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="https://img-blog.csdnimg.cn/20200318092421213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><ol>
<li><p>各层之间互相<strong>独立</strong>，每层只实现一种相对独立的功能。</p>
</li>
<li><p>每层之间<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少。</p>
</li>
<li><p>结构上可分割。每层都采用<strong>最合适的技术</strong>来实现。</p>
</li>
<li><p>保持<strong>下层对上层</strong>的独立性，<strong>上层单向使用下层提供的服务</strong>。</p>
</li>
<li><p>整个分层结构应该能促进标准化工作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/20200323171307621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><p><img src="https://img-blog.csdnimg.cn/2020032317261286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="用户层"><a href="#用户层" class="headerlink" title="用户层"></a>用户层</h4><p>所有能和用户交互产生网络流量的程序</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<p>功能一：数据格式转换<br>功能二：数据加密解密<br>功能三：数据压缩和恢复</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>向表示层实体/用户进程建立连接并在连接上有序地传输数据<br>这是会话，也是建立同步（SYN）</p>
<p>功能一：建立，管理，终止会话<br>功能二：使用校验点可使会话在通信失效时从校验点/同步点继续回复通信，实现数据同步</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>·负责主机中<strong>两个进程</strong>的通信,即<strong>端到端</strong>的通信。传输单位是报文段或用户数据报</p>
<p>功能一：<strong>可</strong>靠传输、不可靠传输<br>功能二：<strong>差</strong>错控制<br>功能三：<strong>流</strong>量控制<br>功能四：复<strong>用</strong>分用</p>
<h4 id="网络层·"><a href="#网络层·" class="headerlink" title="网络层·"></a>网络层·</h4><p>主要任务是把分组从源端传到目的端,为分组交换网上的不同主机提供通信服务。<br>网络层传输单位是数据报</p>
<p>功能一:路由选择<br>功能二:流量控制<br>功能三:差错控制<br>功能四:拥塞控制</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>主要任务是把网络层传下来的数据报组装成帧。数据链路层/链路层的传输单位是帧。</p>
<p>功能一:成帧(定义帧的开始和结束)<br>功能二:差错控制  帧错+位错<br>功能三:流量控制<br>功能四:访问（接入）控制 控制对信道的访问</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>主要任务是在物理媒体上实现比特流的透明传输<br>物理层的传输单位是比特</p>
<p>功能一：定义接口特性<br>功能二：定义传输模式<br>功能三：定义传输速率<br>功能四：比特同步<br>功能五：比特编码</p>
<h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><p><img src="https://img-blog.csdnimg.cn/20200323175216782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200323175806729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200323175635939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200323175710332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X2Zhbmd3ZW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>学习链接为<a href="https://www.bilibili.com/video/BV19E411D78Q?p=10" target="_blank" rel="noopener">b站王道考研 计算机网络</a></p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记3</title>
    <url>/lzfangwen.github.io/2020/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>结点</strong>:主机、路由器</p>
<p><strong>链路</strong>:网络中两个结点之间的<strong>物理通道</strong>,链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p>
<p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p>
<p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p>
<blockquote>
<p><strong>数据链路层</strong>负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p>
</blockquote>
<a id="more"></a>

<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>数据链路层在物理层提供服务的基础上<strong>向网络层提供服务</strong>,其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是<strong>加强物理层传输原始比特流的功能</strong>,将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>,使之对网络层表现为一条无差错的链路。</p>
<ul>
<li>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。有连接一定有确认！</li>
<li>功能二：链路管理，即连接的建立、维持、释放(用于面向连接的服务)。</li>
<li>功能三：组帧。</li>
<li>功能四：流量控制。限制发送方。</li>
<li>功能五：差错控制（帧错/位错）。</li>
</ul>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><strong>封装成帧</strong>就是在一段数据的前后部分添加首部和尾部,这样就构成了一个帧。接收端在收到物理层上交的比特流后,就能根据首部和尾部的标记,从收到的比特流中识别帧的开始和结束。首部和尾部包含许多的控制信息,他们的一个重要作用:<strong>帧定界</strong>(确定帧的界限)。</p>
<p><strong>帧同步</strong>:接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200413/tkTqDi9GvcYN.png" alt="mark"></p>
<p>组帧的四种方法：</p>
<ol>
<li><p>字符计数法</p>
<blockquote>
<p>帧首部使用一个计数字段（第一个字节，八位）来表明帧内字符数。</p>
<img src="http://qiniuyun.lzfangwen.cn/blog/20200413/wL0IDs4VGEjs.png" alt="mark" style="zoom:150%;">
</blockquote>
</li>
<li><p>字符（节）填充法</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200413/mSvO5mxPIhRk.png" alt="mark"></p>
<ul>
<li><p>当传送的帧是由文本文件组成（文本文件的字符都是从键盘上输入的，都是ASCL码）</p>
<p>不管从键盘上输入什么字符都可以在帧内传出,即<strong>透明传输</strong></p>
</li>
<li><p>当传送的帧是由ASCLL码的文本文件组成时（二进制的程序或图像等）就要<strong>采用字符填充的方式实现透明传输</strong>。</p>
</li>
<li></li>
</ul>
</blockquote>
</li>
<li><p>零比特填充法</p>
</li>
</ol>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/NugarvoR0BRL.png" alt="mark"></p>
<p>操作：</p>
<ol>
<li><p>在发送端，扫描整个信息字段，只要连续5个1，就立即填入一个0.</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/M3byTU0i5ojR.png" alt="mark"></p>
</li>
<li><p>在接收端收到一个帧时，先找到标志字段认定边界，再用硬件对比特流进行扫描。发现连续5个1时，就把后面的0删掉</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/rs3YCHovSqpK.png" alt="mark"></p>
</li>
</ol>
</blockquote>
<ol start="4">
<li><p>违规编码法</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/rmAVH2b0hvaH.png" alt="mark"></p>
<p>可以用 <strong>“高高”，“低低”</strong>来定界帧的起始和终止。</p>
</blockquote>
</li>
</ol>
<p>由于字节计数法中COunt字段的脆弱性（其值若有差错将导致灾难性后果）及字符填充实现上的复杂性和不兼容性，目前较为普遍的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong>。</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输是指不管所传数据是什么样的比特组合,都应当能够在链路上传送。因此,链路层就“看不见”有什么妨碍数据传输的东西。当所传数据中</p>
<p>的比特组合恰巧与某一个控制信息完全一样时,就必须采取适当的措施,使收方不会将这样的数据误以为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p>
<h2 id="差错控制（检错编码）"><a href="#差错控制（检错编码）" class="headerlink" title="差错控制（检错编码）"></a>差错控制（检错编码）</h2><p>概括来说，传输的差错都是由于噪声引起的。</p>
<ol>
<li>全局性    由于线路本身电气特性所产生的<strong>随机噪声</strong>(热噪声),是信道固有的,随机存在的。解决办法:提高信噪比来减少或避免干扰。(对传感器下手)</li>
<li>局部性     外界特定的短暂原因所造成的<strong>冲击噪声</strong>,是产生差错的主要原因。通常利用编码技术来解决。</li>
</ol>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/s3DqlvPuuWY7.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/j8mDntj7aj7v.png" alt="mark"></p>
<p>编码的不同</p>
<blockquote>
<p>数据链路层编码和物理层的数据编码与调制<strong>不同</strong>。</p>
<p><strong>物理层编码针对的是**</strong>单个比特**,解决传输过程中比特的同步等问题,如曼彻斯特编码。</p>
<p>而数据链路层的编码针对的是<strong>一组比特</strong>,它通过冗余码的技术实现一组二进制比特串在传输过程是否出现了差错。</p>
</blockquote>
<h3 id="奇偶检验码"><a href="#奇偶检验码" class="headerlink" title="奇偶检验码"></a><strong>奇偶检验码</strong></h3><blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/OlVoquTv6wQa.png" alt="mark"></p>
<p>特点：只能检查出奇数个比特错误，检错能力位50%。</p>
</blockquote>
<h3 id="CRC循环冗余码"><a href="#CRC循环冗余码" class="headerlink" title="CRC循环冗余码"></a><strong>CRC循环冗余码</strong></h3><blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/EmRGBYEdxWkL.png" alt="mark"></p>
<p>eg.    要发送的数据是1101 0110 11，采用CRC检验，生成多项式是10011，        那么最终发送的数据应该是？</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/faDG56TaMOSg.png" alt="mark"></p>
<p>guo<img src="http://qiniuyun.lzfangwen.cn/blog/20200414/NbeDaVeDmQiJ.png" alt="mark"></p>
<p><strong>接收端检错过程</strong>    </p>
<p>​    把收到的每一个帧都除以同样的除数,然后检查得到的余数R.</p>
<ol>
<li><p>余数为0,判定这个帧没有差错,<strong>接受</strong>。</p>
</li>
<li><p>余数为不为0,判定这个帧有差错(无法确定到位) ,<strong>丢弃</strong>。</p>
<p> FCS的生成以及接收端CRC检验都是由<strong>硬件</strong>实现,处理很迅速,因此不会延误数据的传输。</p>
</li>
</ol>
</blockquote>
<p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术,只能做到对帧的无差错接收,即“凡是接收端数据链路层接受的帧,我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了,但是最终还是因为有差错被丢弃。“凡是接收端数据链路层接收的帧均无差错”</p>
<p>“可靠传输” :数据链路层发送端发送什么,接收端就收到什么。</p>
<p>链路层使用CRC检验,能够实现无比特差错的传输,但这还不是可靠传输。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记6</title>
    <url>/lzfangwen.github.io/2020/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/</url>
    <content><![CDATA[<h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h2><blockquote>
<p>局域网(Local Area Network) :简称<strong>LAN</strong>,是指在某一区域内由多台计算机互联成的计算机组,使用<strong>广播信道</strong>。</p>
<ul>
<li>覆盖的地理范围较小,只在一个相对独立的局部范围内联,如一座或集中的建筑群内。</li>
<li>使用专门铺设的传输介质(双绞线、同轴电缆)进行联网,数据传输高(10Mb/s~10Gb/s)</li>
<li>通信延迟时间短,误码率低,可靠性较高。</li>
<li>各站为平等关系,共享传输信道。</li>
</ul>
<p>决定局域网的主要要素为:<strong>网络拓扑</strong>,<strong>传输介质</strong>与<strong>介质访问控制方法</strong>。</p>
</blockquote>
<a id="more"></a>

<h3 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/NE8p3jpibvgR.png" alt="mark"></p>
<h3 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h3><blockquote>
<ul>
<li>有线局域网<ul>
<li>常用介质：双绞线、同轴电缆、光纤</li>
</ul>
</li>
<li>无限局域网<ul>
<li>常用介质：电磁波</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h3><blockquote>
<ol>
<li><p>CSMA/CD     常用于<strong>总线型局域网</strong>，也用于树型网络</p>
</li>
<li><p>令牌总线       常用于<strong>总线型局域网</strong>,也用于树型网络</p>
<p>​                       它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线,才有发送信息的权力。</p>
</li>
<li><p>令牌环           用于<strong>环形局域网</strong>，如令牌环网</p>
</li>
</ol>
</blockquote>
<h3 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h3><blockquote>
<ol>
<li><strong>以太网</strong>    以太网是应用最为广泛的局域网,包括标准以太网(10Mbps)、快速以太网(100Mbps)千兆以太网(1000 Mbps)和10G以太网,它们都符合<strong>IEEE802.3</strong>系列标准规范。逻辑拓扑总线型,物理拓扑是星型或拓展星型。使用CSMA/CD.2</li>
<li><strong>令牌环网</strong>   物理上采用了星形拓扑结构,逻辑上是环形拓扑结构。已是“明日黄花”。</li>
<li><strong>FDDI网(Flber Distriburted Data Interface)</strong>      物理上采用了双环拓扑结构,逻辑上是环形拓扑结构。</li>
<li><strong>ATM网(Asynchronous Transfer Mode)</strong>       较新型的单元交换技术,使用53字节固定长度的单元进行交换。</li>
<li><strong>无线局域网(Wireless Local Area Network; WLAN)</strong>     采用<strong>IEEE 802.11标准</strong>。</li>
</ol>
</blockquote>
<h3 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h3><blockquote>
<p>EEE 802系列标准是IEEE 802 LAN/MAN标准委员会制定的局域网、城域网技术标准(1980年2月成立)。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个,专门工作组负责。</p>
</blockquote>
<blockquote>
<p>IEEE 802.3:以太网介质访问控制协议(CSMA/CD)及物理层技术规范</p>
<p>IEEE 802.5 :令牌环网(Token-Ring)的介质访问控制协议及物理层技术规范。</p>
<p>LEEE 802.8:光纤技术咨询组,提供有关光纤联网的技术咨询。</p>
<p>IEEE 802.11:无线局城网(WLAN)的介质访问控制协议及物理层技术规范</p>
</blockquote>
<h3 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h3><blockquote>
<p><strong>链路层的两个控制子层</strong></p>
<p>IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的<strong>数据链路层与物理层</strong>,它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/ihbhtJk2W8Of.png" alt="mark"></p>
</blockquote>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><blockquote>
<p>以太网(Ethernet)指的是由xerox公司创建并由Xerox, Intel和DEC公司联合开发的基带总线局域网规范,是当今域网采用的最通用的通信协议标准。以太网络使用CSMA/CD (载波监听多检测)技术。</p>
</blockquote>
<h3 id="以太网在局域网各种技术中占统治性地位"><a href="#以太网在局域网各种技术中占统治性地位" class="headerlink" title="以太网在局域网各种技术中占统治性地位:"></a><strong>以太网在局域网各种技术中占统治性地位:</strong></h3><blockquote>
<ol>
<li>造价低廉(以太网网卡不到10                                               块) ;</li>
<li>是应用最广泛的局域网技术;</li>
<li>比令牌环网、ATM网便宜,简单;</li>
<li><strong>满足网络速率要求: 10Mb/s~10Gb/s.</strong></li>
</ol>
</blockquote>
<h3 id="以太网两个标准"><a href="#以太网两个标准" class="headerlink" title="以太网两个标准"></a><strong>以太网两个标准</strong></h3><blockquote>
<p>DIX Ethernet V2:第一个局域网产品(以太网)规约。</p>
<p>IEE 802.3: IEE 802委员会802.3工作组制定的第一个IEE的以太网标准。(帧格式有一丢丢改动)</p>
</blockquote>
<p><strong>802.3局域网 AKA</strong> <strong>以太网</strong>[^1]</p>
<p>[^1]: Also Known As”的缩写，意思是又名、亦称、也被称为</p>
<h3 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a><strong>以太网提供无连接、不可靠的服务</strong></h3><ul>
<li><strong>无连接</strong>:发送方和接收方之间无“握手过程”。</li>
<li><strong>不可靠</strong>:不对发送方的数据帧编号,接收方不向发送方进行确认,差错帧直接丢弃,差错纠正由高层负责。</li>
<li>以太网只实现无差错接收,不实现可靠传输。</li>
</ul>
<h3 id="以太网传输介质与拓扑结构的发展"><a href="#以太网传输介质与拓扑结构的发展" class="headerlink" title="以太网传输介质与拓扑结构的发展"></a><strong>以太网传输介质与拓扑结构的发展</strong></h3><blockquote>
<p>​                    粗同轴电缆—-&gt;细同轴电缆—–&gt;双绞线+集线器</p>
<p>物理拓扑         总线型——————————&gt;星型</p>
<blockquote>
<p>使用集线器的以太网在逻辑上仍是一个总线网,</p>
<p>各站共享逻辑上的总线,使用的还是CSMA/CD协议</p>
<p>以太网拓扑:<strong>逻辑上总线型,物理上星型。</strong></p>
</blockquote>
</blockquote>
<h3 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a><strong>10BASE-T以太网</strong></h3><blockquote>
<p>10BASE-T是传送基带信号的双绞线以太网, T表示采用双绞线,现10BASE-T采用的是无屏蔽双绞线(UTP) ,传输速率是<strong>10Mb/s</strong></p>
<p>物理上采用星型拓扑,逻辑上总线型,每段双绞线最长为100m。</p>
<p>采用<strong>曼特斯特编码</strong></p>
<p>采用CSMA/CA介质访问控制</p>
</blockquote>
<h3 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a><strong>适配器与MAC地址</strong></h3><blockquote>
<p>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。</p>
<p>网络接口板</p>
<p>网络接口卡NIC (network interface card)</p>
<p>Now,不再使用单独网卡。</p>
<p>适配器上装有处理器和存储器(包括RAM和ROM)</p>
<p>ROM上有计算机硬件地址<strong>MAC地址</strong></p>
<p>在局域网中,硬件地址又称为物理地址,或MAC地址。【实际上是标识符】</p>
<p>MAC地址:每个适配器有一个全球唯一的48位二进制地址,前24位代表厂家(由IEEE规定),后24位厂家自己指定。常用6个十六进制数表示,如02-60-8c-e4-b1-21</p>
</blockquote>
<h3 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a><strong>以太网MAC帧</strong></h3><blockquote>
<p>最常用的MAC帧是以太网V2的格式</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/KMROh3tLvfiA.png" alt="mark"></p>
<p>与IEE 802.3的区别: 1.第三个字段是长度/类型2.当长度/类型字段值小于0x0600时,数据字段必须装入LLC子层。</p>
</blockquote>
<h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a><strong>高速以太网</strong></h3><blockquote>
<p>速率2100Mb/s的以太网称为高速以太网。</p>
<ol>
<li><p><strong>100BASE-T以太网</strong></p>
<p>在双绞线上传送100Mb/s基带信号的星型拓扑以太网,仍使用IEEE802.3的CSMA/CD协议。支持全双工和半双工，可在全双工方式下工作而无冲突。</p>
</li>
<li><p><strong>吉比特以太网</strong></p>
<p>在光纤或双绞线上传送1Gb/s信号</p>
<p>支持全双工和半双工，可在全双工方式下工作而无冲突。</p>
</li>
<li><p><strong>10吉比特</strong></p>
<p>10吉比特以太网在光纤上传送10Gb/s信号。</p>
<p>只支持全双工，无争用问题。</p>
</li>
</ol>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记4</title>
    <url>/lzfangwen.github.io/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h2 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><h3 id="数据链路层的流量控制"><a href="#数据链路层的流量控制" class="headerlink" title="数据链路层的流量控制"></a>数据链路层的流量控制</h3><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p>
<a id="more"></a>

<p><strong>数据链路层</strong>的流量控制是点对点的,而传输层的流量控制是端到端的</p>
<p>数据链路层流量控制手段:接收方收不下就不回复确认。</p>
<p>传输层流量控制手段:接收端给发送端一个窗口公告。</p>
<blockquote>
<p>停止-等待协议</p>
<ul>
<li>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</li>
</ul>
<p>滑动窗口协议</p>
<ul>
<li><p>退后N帧协议（GBN）</p>
</li>
<li><p>选择重传协议（SR）</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/kPYDDdRbJilP.png" alt="mark"></p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>停止等待协议</strong>               发送窗口大小=1,接收窗口大小=1;,</p>
<p><strong>后退N帧协议(GBN)</strong>    发送窗口大小&gt;1,接收窗口大小=1;</p>
<p><strong>选择重传协议(SR</strong>)       发送窗口大小&gt;1,接收窗口大小&gt;1;</p>
</blockquote>
<h3 id="可靠传输、滑动窗口、流量控制的关系"><a href="#可靠传输、滑动窗口、流量控制的关系" class="headerlink" title="可靠传输、滑动窗口、流量控制的关系"></a>可靠传输、滑动窗口、流量控制的关系</h3><p>可靠传输:发送端发啥,接收端收啥。</p>
<p>流量控制:控制发送速率,使接收方有足够的缓冲空间来接收每一个帧。</p>
<p>滑动窗口解决</p>
<ul>
<li>流量控制(收不下就不给确认,想发也发不了)</li>
<li>可靠传输(发送方自动重传)</li>
</ul>
<h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><ol>
<li><p>为什么要有停止等待协议?</p>
<blockquote>
<p>除了比特出差错,底层信道还会出现丢包问题。</p>
<p>丢包:物理线路故障、设备故障、病毒攻击、路由信息错误等原因,会导致数据包的丢失。</p>
</blockquote>
</li>
<li><p>研究停等协议的前提?</p>
<blockquote>
<p>虽然现在常用全双工通信方式,但为了讨论问题方便,仅考虑一方发送数据(发送方) ,一方接收数据.(接收方) 。</p>
<p>因为是在讨论可靠传输的原理,所以并不考虑数据是在哪一个层次上传送的。</p>
<p>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p>
</blockquote>
</li>
<li><p>停等协议有几种应用情况？</p>
<blockquote>
<p>无差错情况</p>
<p>有差错情况</p>
</blockquote>
</li>
</ol>
<h3 id="停等协议-无差错情况"><a href="#停等协议-无差错情况" class="headerlink" title="停等协议-无差错情况"></a>停等协议-无差错情况</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/7DscfeuaY4cj.png" alt="mark"></p>
<h3 id="停等协议-有差错情况"><a href="#停等协议-有差错情况" class="headerlink" title="停等协议-有差错情况"></a>停等协议-有差错情况</h3><ol>
<li><p>数值帧丢失或检测到帧出错</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/thOXM47pNWxl.png" alt="mark"></p>
<p>注意</p>
<ol>
<li>发完一个帧后，必须保留它的副本。</li>
<li>数据帧和确认帧必须编号。</li>
</ol>
</blockquote>
</li>
<li><p>ACK丢失</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/ud9NSxsXnDDt.png" alt="mark"></p>
</blockquote>
</li>
<li><p>ACK迟到</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/OQmAK4nJMpk3.png" alt="mark"></p>
</blockquote>
</li>
</ol>
<h3 id="停等协议性能分析"><a href="#停等协议性能分析" class="headerlink" title="停等协议性能分析"></a>停等协议性能分析</h3><ul>
<li><strong>简单</strong></li>
<li><strong>信道利用率太低</strong></li>
</ul>
<p><strong>信道利用率</strong></p>
<blockquote>
<p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/XaSOl0MxCDEt.png" alt="mark"></p>
<p>信道吞吐率=信号利用率*发送方的发送速率</p>
</blockquote>
<p>eg.</p>
<blockquote>
<p>例题:一个信道的数据传输率为4kb/s ,单向传播时延为30ms ,如果使停止等待协议的信道最大利用率达到80% ,要求的数据帧长度至少为( )。</p>
<p>$80%= \frac{L/4}{L/4+2*30ms}$</p>
<p>​        $=\frac{L}{L+2<em>30ms</em>4kb/s}$</p>
<p>​        $=960bit$</p>
</blockquote>
<h2 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h2><p> 发送窗口：发送方维持一组连续的允许发送的序号</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/v54DUuHLkxui.png" alt="mark"></p>
</blockquote>
<h3 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h3><ol>
<li><p>上层的调用</p>
<blockquote>
<p>上层要发送数据时,发送方先检查发送窗口是否已满,如果未满,则产生一个帧并将其发送;如果窗口已满,发送方只需将数据返回给上层,暗示上层窗口已满。上层等一会再发送。(实际实现中,发送方可以缓存这些数据,窗口不满时再发送帧)</p>
</blockquote>
</li>
<li><p>收到了一个ACK</p>
<blockquote>
<p>GBN协议中,对n号帧的确认采用<strong>累积确认</strong>的方式,标明接收方已经收到n号帧和它之前的全部帧。</p>
</blockquote>
</li>
<li><p>超时时间</p>
<blockquote>
<p>协议的名字为后退N帧/回退N帧,来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样,定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时,发送方重传所有己发送但未被确认的帧。</p>
</blockquote>
</li>
</ol>
<h3 id="接收方要做的事"><a href="#接收方要做的事" class="headerlink" title="接收方要做的事"></a>接收方要做的事</h3><blockquote>
<p>如果正确收到n号帧,并且<strong>按序</strong>,那么接收方为n帧发送一个ACK,并将该帧中的数据部分交付给上层。</p>
</blockquote>
<blockquote>
<p>其余情况都丢弃帧,并最近<strong>按序</strong>接收的帧重新发送ACK,接收方无需缓存任何失序帧,只需要维护一个信息: expectedseqnum (下一个按序接收的帧序号)。</p>
</blockquote>
<h2 id="运行中的GBN"><a href="#运行中的GBN" class="headerlink" title="运行中的GBN"></a>运行中的GBN</h2><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/G4AD0skCajbn.png" alt="mark"></p>
<h3 id="滑动窗口长度"><a href="#滑动窗口长度" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h3><p>若采用n个比特对帧编号,那么发送窗口的尺寸W,应满足: $1\leq W_T\leq2^n-1$。因为发送窗口尺寸过大,就会使得接收方无·法区别薪帧和旧帧。</p>
<h3 id="GBN协议总结"><a href="#GBN协议总结" class="headerlink" title="GBN协议总结"></a>GBN协议总结</h3><blockquote>
<ol>
<li>累计确认（偶尔捎带确认）</li>
<li>接收方只按顺序接收帧，不按序无情丢弃</li>
<li>确认序列最大的、按序到达的帧</li>
<li>发送窗口最大为$2^n-1$，接收窗口大小为1</li>
</ol>
</blockquote>
<p>eg.</p>
<blockquote>
<p>数据链路层采用了后退N帧( GBN )协议,发送方已经发送了编号为0~7的帧。当计时器超时时,若发送方只收到0、2、3号帧的确认,则发送方需要重发的帧数是( )。</p>
<p>A.2        B.3        C.4        D.5</p>
<p>答案为 C</p>
</blockquote>
<h2 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h2><p><strong>滑动窗口</strong></p>
<img src="http://qiniuyun.lzfangwen.cn/blog/20200414/U4wlqsIqIy8I.png" alt="mark">

<h3 id="SR发送方必须响应的三件事"><a href="#SR发送方必须响应的三件事" class="headerlink" title="SR发送方必须响应的三件事"></a>SR发送方必须响应的三件事</h3><ol>
<li><p>上层的调用</p>
<blockquote>
<p>从上层收到数据后, SR发送方检查下一个可用于该帧的序号,如果序号位于发送窗口内,则发送数据帧;否·则就像GBN一样,要么将数据缓存,要么返回给上层之后再传输。</p>
</blockquote>
</li>
<li><p>收到了一个ACK</p>
<blockquote>
<p>如果收到ACK,加入该帧序号在窗口内,则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界(最左边第一个窗口对应的序号) ,则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧,则发送这些帧。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/LAQGQwgEUlF3.png" alt="mark"></p>
</blockquote>
</li>
<li><p>超时事件</p>
<blockquote>
<p>每个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</p>
</blockquote>
</li>
</ol>
<h3 id="SR接收方要做的事"><a href="#SR接收方要做的事" class="headerlink" title="SR接收方要做的事"></a>SR接收方要做的事</h3><p>来者不拒（窗口内的帧）</p>
<blockquote>
<p>SR接收方将<strong>确认一个正确接收的帧</strong>而<strong>不管其是否按序</strong>。失序的帧将被<strong>缓存</strong>,并返回给发送方一个该帧的确认帧【<strong>收谁确认谁</strong>】,直到所有帧(即序号更小的帧)皆被收到为止,这时才可以将一批帧按序交付给上层,然后<strong>向前移动窗口</strong></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/uH29ggc3tGbq.png" alt="mark"></p>
<p>如果收到了窗口序号外(小于窗口下界)的帧,就返回一个ACK</p>
<p>其他情况,就忽略该帧。</p>
</blockquote>
<h3 id="运行中的SR"><a href="#运行中的SR" class="headerlink" title="运行中的SR"></a>运行中的SR</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200414/EvueR5527V2N.png" alt="mark"></p>
<h3 id="滑动窗口长度-1"><a href="#滑动窗口长度-1" class="headerlink" title="滑动窗口长度"></a>滑动窗口长度</h3><p>发送窗口最好等于接收窗口。（大了会溢出，小了没意义）</p>
<p>$W_{Tmax}=W_{Rmax}=2^{(n-1)}$</p>
<h3 id="SR协议重点总结"><a href="#SR协议重点总结" class="headerlink" title="SR协议重点总结"></a>SR协议重点总结</h3><blockquote>
<ol>
<li>对数据帧逐一确认，收一个确认一个</li>
<li>只重传出错帧</li>
<li>接收帧有缓存</li>
<li>$W_{Tmax}=W_{Rmax}=2^{(n-1)}$</li>
</ol>
</blockquote>
<p>eg.</p>
<blockquote>
<p>数据链路层采用了选择重传( SR )协议,发送方已经发送了编号为0~3的帧。现已收到1号帧的确认,而0、2号帧依次超时,则发送方需要重传的帧数是(  )。</p>
<p>A.2         B.3         C.4         D.5</p>
<p>答案为 A </p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记5</title>
    <url>/lzfangwen.github.io/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><a id="more"></a>

<h2 id="传输数据使用的两种链路"><a href="#传输数据使用的两种链路" class="headerlink" title="传输数据使用的两种链路"></a>传输数据使用的两种链路</h2><ul>
<li><p><strong>点对点链路</strong></p>
<p>​    两个相邻节点通过一个链路相连,没有第三者。</p>
<p>​    应用: PPP协议,常用于<strong>广域网</strong>。</p>
</li>
<li><p><strong>广播式链路</strong></p>
<p>​    所有主机共享通信介质。</p>
<p>​    应用:早期的总线以太网、无线局域网,常用于<strong>局域网</strong>。</p>
<p>​    典型拓扑结构:总线型、星型(逻辑总线型)</p>
</li>
</ul>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>介质访问控制的内容就是,采取一定的措施,使得两对节点之间的通信不会发生互相干扰的情况</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200415/sYksTMKwnq4r.png" alt="mark"></p>
<blockquote>
<p>信道划分介质访问控制(<strong>MAC</strong> Mutiple Access Control )协议:</p>
<ul>
<li><p>基于多路复用技术划分资源。</p>
</li>
<li><p><strong>网络负载重</strong>:共享信道效率高,且公平</p>
</li>
<li><p><strong>网络负载轻</strong>:共享信道效率低</p>
</li>
</ul>
<p>随机访问MAC协议:<strong>冲突</strong></p>
<ul>
<li>用户根据意愿随机发送信息,发送信息时可独占信道带宽。</li>
<li><strong>网络负载重</strong>:产生冲突开销</li>
<li><strong>网络负载轻</strong>:共享信道效率高,单个结点可利用信道全部带宽</li>
</ul>
<p>轮询访问MAC协议/轮流协议/轮转访问MAC协议:</p>
<ul>
<li>既要不产生冲突,又要发送时占全部带宽<ul>
<li>轮询协议</li>
<li>令牌传递协议</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="静态划分信道–信道划分介质访问控制"><a href="#静态划分信道–信道划分介质访问控制" class="headerlink" title="静态划分信道–信道划分介质访问控制"></a>静态划分信道–信道划分介质访问控制</h3><p>信道划分介质访问控制:将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开,把时域和频域资源合理地分配给网络上的设备。</p>
<p><strong>多路复用技术</strong></p>
<blockquote>
<p>把多个信号组合在一条物理信道上进行传输,使得多个计算机或终端设备共享信道资源,</p>
</blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200415/EX6QzW3QhwRs.png" alt="mark"></p>
<h4 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h4><blockquote>
<p>用户在分配到一定的频带后,在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(频率带宽)资源。</p>
<p>充分利用传输介质带宽,系统效率较高;由于技术比较成熟,实现也比较容易。</p>
</blockquote>
<h4 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h4><blockquote>
<p>将时间划分为一段段等长的时分复用帧(TDM帧) 。每一个时分复用的用户在每一个TDM帧中占用<strong>固定序号的时隙</strong>,所有用户轮流占用信道。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200415/rkTVm2dncpvv.png" alt="mark"></p>
</blockquote>
<h4 id="改进的时分复用–统计时分复用STDM"><a href="#改进的时分复用–统计时分复用STDM" class="headerlink" title="改进的时分复用–统计时分复用STDM"></a>改进的时分复用–统计时分复用STDM</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200415/NYeFWCjkktsv.png" alt="mark"></p>
<h4 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h4><blockquote>
<p>波分多路复用就是<strong>光的频分多路复用</strong>,在一根光纤中传输多种不同波长(频率)的光信号,由于波长(频率)·不同,所以各路光信号互不干扰,最后再用波长分解复用器将各路波长分解出来。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200415/zaVPLjexWx1C.png" alt="mark"></p>
</blockquote>
<h4 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a>码分多路复用CDM</h4><blockquote>
<p><strong>码分多址(CDMA)是码分复用的一种方式</strong></p>
<p>一个比特分为多个码片/芯片(chip),每个站点被指定一个唯一的m位的芯片序列。</p>
<p>发送1时站点发送芯片序列，发送0时发送芯片序列反码(通常把0写成-1)</p>
<p><strong>如何不打架</strong>：多个站点同时发送数据的时候，要求各个站点芯片序列相互正交</p>
<p><strong>如何合并</strong>：各路数据在信道中被线性相加。</p>
<p><strong>如何分离</strong>：合并的数据和源站规格化内积。、</p>
</blockquote>
<h3 id="动态分配信道"><a href="#动态分配信道" class="headerlink" title="动态分配信道"></a>动态分配信道</h3><blockquote>
<p><strong>动态媒体接入控制/多点接入</strong></p>
<p>特点：信道并非在用户通信时固定分配用户</p>
</blockquote>
<p><strong>随机访问介质访问控制</strong></p>
<blockquote>
<p>所有用户可随机发送信息。</p>
<p>发送信息时占<strong>全部带宽</strong></p>
<p>不协调-&gt;冲突</p>
</blockquote>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><h5 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h5><blockquote>
<p>思想：不监听信道，不按时间槽发送，随机发送。<strong>想发就发</strong></p>
<p>冲突如何检测?</p>
<ul>
<li>如果发生冲突,接收方在就会检测出差错,然后不予确认,发送方在一定时间内收不到就判断发生冲突。</li>
</ul>
<p>冲突如何解决?</p>
<ul>
<li>超时后等一随机时间再重传。</li>
</ul>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/BqBp9elChVEh.png" alt="mark"></p>
</blockquote>
<h5 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h5><blockquote>
<p>时隙ALOHA协议的思想:把时间分成若干个相同的时间片,所有用户在时间片开始时刻同步接入网络信道,若发生冲突,则必须等到下一个时间片开始时刻再发送。<strong>控制想发就发的随意性</strong></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/jciHBEkR4HYc.png" alt="mark"></p>
</blockquote>
<h5 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h5><blockquote>
<ol>
<li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li>
<li>纯ALOHA想发就发，时隙ALOHA只有时间片段开始时才能发</li>
</ol>
</blockquote>
<h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><blockquote>
<p>载波监听多路访间协议CSMA (carrier sense multiple access)</p>
</blockquote>
<blockquote>
<p>cs:载波侦听/监听,每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>
<p>MA:多点接入,表示许多计算机以多点接入的方式连接在一根总线上。</p>
</blockquote>
<h5 id="坚持CSMA"><a href="#坚持CSMA" class="headerlink" title="坚持CSMA"></a>坚持CSMA</h5><blockquote>
<p>坚持指的是对于监听信道<strong>忙</strong>之后的坚持。</p>
<p>坚持CSMA思想:如果一个主机要发送消息,那么它先监听信道。</p>
<ul>
<li><p><strong>空闲则直接传输,不必等待。</strong></p>
</li>
<li><p><strong>忙则一直监听,直到空闲马上传输。</strong></p>
</li>
<li><p>如果有冲突(一段时间内未收到肯定回复) ,则等待一个随机长的时间再监听,重复上述过程。</p>
<p>优点:只要媒体空闲,站点就马上发送,避免了媒体利用率的损失。</p>
<p>缺点:假如有两个或两个以上的站点有数据想发送，冲突就不可避免。</p>
</li>
</ul>
</blockquote>
<h6 id="非坚持CAMA"><a href="#非坚持CAMA" class="headerlink" title="非坚持CAMA"></a>非坚持CAMA</h6><blockquote>
<p>非坚持指的是对于监听信道<strong>忙</strong>之后就不继续监听。</p>
<p>非坚持CSMA思想:如果一个主机要发送消息,那么它先监听信道。</p>
<ul>
<li><p><strong>空闲则直接传输,不必等待。</strong></p>
</li>
<li><p><strong>忙则等待一个随机的时间之后再进行监听。</strong></p>
<p>优点:采用随机的重发延迟时间可以减少冲突发生的可能性。</p>
<p>缺点:可能存在大家都在延迟等待过程中,使得媒体仍可能处于空闲状态,媒体使用率降低。</p>
</li>
</ul>
</blockquote>
<h5 id="p-坚持CSMA"><a href="#p-坚持CSMA" class="headerlink" title="p-坚持CSMA"></a>p-坚持CSMA</h5><blockquote>
<p>p-坚持指的是对于监听信道<strong>空闲</strong>的处理。</p>
<p>p-坚持CSMA思想:如果一个主机要发送消息,那么它先监听信道。</p>
<ul>
<li><p><strong>空闲则以p概率直接传输,不必等待;概率1-p等待到下一个时间槽再传输。</strong></p>
</li>
<li><p><strong>忙着等待一个随机的时间之后再进行监听</strong></p>
<p>优点：既能像非坚持算法那样减少冲突,又能像坚持算法那样减少媒体空闲时间的这种方案</p>
<p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费</p>
</li>
</ul>
</blockquote>
<h5 id="三种CSMA对比区别"><a href="#三种CSMA对比区别" class="headerlink" title="三种CSMA对比区别"></a>三种CSMA对比区别</h5><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/zufy2rGaFmyv.png" alt="mark"></p>
<h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h4><blockquote>
<p> 载波监听多点接入/碰撞检测CSMA/CD (carrier sense multiple access with collision detection)</p>
</blockquote>
<blockquote>
<p><strong>CS</strong>:载波侦听/监听,每一个站在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算c机在发送数据。</p>
<p><strong>MA</strong>:多点接入,表示许多计算机以多点接入的方式连接在一根总线上。<strong>总线型网络</strong>,</p>
<p><strong>CD</strong>:碰撞检测(冲突检测) , “<strong>边发送边监听</strong>” ,适配器边发送数据边检测信道上信号电压的变化情况,以便判断自己在发送数据时其他站是否也在发送数据。<strong>半双工网络</strong></p>
</blockquote>
<h5 id="传播时延对载波监听的影响"><a href="#传播时延对载波监听的影响" class="headerlink" title="传播时延对载波监听的影响"></a>传播时延对载波监听的影响</h5><blockquote>
<p>最迟多久才能知道自己发送的数据没和别人碰撞?</p>
<ul>
<li><p>最多是两倍的总线端到端的传播时延(2$\tau$)</p>
</li>
<li><p>总线的端到端往返传播时延争用期/冲突窗口/碰撞窗口</p>
<p>只要经过2$\tau$时间还没有检测到碰撞,就能肯定这次发送不会发生碰撞。</p>
</li>
</ul>
</blockquote>
<h5 id="如何确定碰撞后的重传时机"><a href="#如何确定碰撞后的重传时机" class="headerlink" title="如何确定碰撞后的重传时机"></a>如何确定碰撞后的重传时机</h5><p><strong>截断二进制指数规避算法</strong></p>
<blockquote>
<ol>
<li>确定基本退避(<strong>推迟</strong>)时间为争用期2$\tau$。</li>
<li>定义参数k,它等于<strong>重传次数</strong>,但k不超过10,即k-mint[重传次数, 10]。当重传次数不超过10时, k等于重传次数;当重传次数大于10时, k就不再增大而一直等于10。</li>
<li>从离散的整数集合<strong>[0,1,2k-1]</strong>中随机取出一个数r,重传所需要退避的时间就是r倍的基本退避时间,即2r$\tau$。</li>
<li>当重传达<strong>16次</strong>仍不能成功时,说明网络太拥挤,认为此帧永远无法正确发出,抛弃此帧并向高层报告出错。</li>
</ol>
<ul>
<li>第一次重传, k-1, r从{0, 1}选;</li>
<li>重传推迟时间为0或2$\tau$,在这两个时间中随机选一个;,</li>
<li>若再次碰撞,则在第二次重传时, k-2, r从{0, 1, 2, 3}选;</li>
<li>重传推迟时间为0或2$\tau$或4$\tau$或6$\tau$,在这四个时间中随机选一个;</li>
<li>若再次碰撞,则第三次重传时, k=3,r从10, 1, 2, 3, 4, 5, 6, 7选……</li>
</ul>
<p><strong>若连续多次发生冲突,就表明可能有较多的站参与争用信道。使用此算法可使重传需要推迟的平均时间随重传次数的增大而增大,因而减小发生碰撞的概率,有利于整个系统的稳定。</strong></p>
</blockquote>
<p>eg.</p>
<blockquote>
<p>例:在以太网的二进制回退算法中,在11次碰撞之后,站点会在0~ (? )之间选择一个随机数。</p>
<p>k=min{11,10}=10</p>
<p>$2^k-1=2^{10}-1=1023$</p>
<p>r$\in$[0,1,2,,1023]</p>
</blockquote>
<h5 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h5><blockquote>
<p>帧的传输时延至少要两倍于信号在总线中的传播时延。</p>
<p>$$\frac {帧长(bit)}{数据传输速率} \geq 2\tau$$</p>
<p>最小帧长=总线传播时延$\times$数据传输速率$\times$2</p>
<p>2$\tau\times$数据传输速率</p>
<p><strong>以太网规定最短帧长为64B,凡是长度小于64B的都是由于冲突而异常终止的无效帧。</strong></p>
</blockquote>
<h4 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h4><blockquote>
<p>载波监听多点接入/碰撞避免CSMA/CA (carrier sense multiple access with collision avoidance)</p>
</blockquote>
<blockquote>
<p>发送数据前,先检测信道是否空闲。</p>
<p>空闲则发出<strong>RTS (request to send)</strong> , RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息;信道忙则等待。</p>
<p>接收端收到RTS后,将响应<strong>CTS (clear to send)</strong></p>
<p>发送端收到CTS后,开始发送数据帧(同时<strong>预约信道</strong>:发送方告知其他站点自己要传多久数据)</p>
<p>接收端收到数据帧后,将用CRC来检验数据是否正确,正确则响应<strong>ACK帧</strong>。</p>
<p>发送方收到ACK就可以进行下一个数据帧的发送,若没有则一直重传至规定重发次数为止(采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间)</p>
</blockquote>
<blockquote>
<ol>
<li><strong>预约信道</strong></li>
<li><strong>ACK帧</strong></li>
<li><strong>RTS/CTS帧</strong></li>
</ol>
</blockquote>
<p><strong>CSMA/CD与CSMA/CA</strong></p>
<blockquote>
<p>相同点:</p>
<ul>
<li>CSMA/CD与CSMA/CA机制都从属于CSMA的思路,其核心是<strong>先听再说</strong>。换言之,两个在接入信道之前都须要进行监听。当发现信道空闲后,才能进行接入。</li>
</ul>
<p>不同点:</p>
<ol>
<li><strong>传输介质不同</strong>: CSMA/CD用于总线式以太网【有线】 ,而CSMA/CA用于无线局域网【无线】。</li>
<li><strong>载波检测方式不同</strong>:因传输介质不同, CSMA/CD与CSMA/CA的检测方式也不同。CSMA/CD通过电缆中电压的变化来检测,当数据发生碰撞时,电缆中的电压就会随着发生变化;而CSMA/CA采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式。</li>
<li><strong>CSMA/CD检测冲突, CSMA/CA避免冲突</strong>,二者出现冲突后都会进行<strong>有上限的重传</strong>。</li>
</ol>
</blockquote>
<h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><blockquote>
<p>主节点轮流“邀请”从属节点发送数据</p>
<ol>
<li>轮询开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ol>
</blockquote>
<h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><blockquote>
<p>令牌:一个特殊格式的MAC控制帧,不含任何信息。控制信道的使用,确保同一时刻只有一个结点独占信道。</p>
<p><strong>令牌环网无碰撞</strong></p>
<p>每个结点都可以在一定时间内（令牌持有时间）获得发送数据的权力，并不是无限制地持有令牌</p>
<p>问题：</p>
<ol>
<li><p>令牌开销</p>
</li>
<li><p>等待延迟</p>
</li>
<li><p>单点故障</p>
</li>
</ol>
<p>应用于令牌环网（物理星型拓扑，逻辑环形拓扑）。</p>
<p>采用令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/pMVfBycSrE7i.png" alt="mark"></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记7</title>
    <url>/lzfangwen.github.io/2020/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/</url>
    <content><![CDATA[<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><a id="more"></a>

<h3 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/9FDVa0Dj8ITL.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/OWn93V1O0TLM.png" alt="mark"></p>
<h3 id="无线局域网的分类"><a href="#无线局域网的分类" class="headerlink" title="无线局域网的分类"></a>无线局域网的分类</h3><ol>
<li><p>有固定基础设施无线局域网</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/4nCfiC6IW7Gq.png" alt="mark"></p>
</blockquote>
</li>
<li><p>无固定基础设施无线局域网的自组织网络</p>
<blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/6N8EyLb3KLE6.png" alt="mark"></p>
</blockquote>
</li>
</ol>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>广域网(WAN, Wide Area Network) ,通常跨接很大的物理范围,所覆盖的范围从几十公里到几千公里,它能连接多个城市或国家,或横跨几个洲并能提供远距离通信,形成国际性的远程网络。</p>
<p>广域网的通信子网主要使用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网,它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来,达到<strong>资源共享</strong>的目的。如因特网(Internet)是世界范围内最大的广域网。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/Wapjw33KX3z1.png" alt="mark"></p>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p>点对点协议PP (Point-to-Point Protocol)是目前使用最广泛的数据链路层协议,用户使用拨号电话接入因特网时一般都使用PPP协议。</p>
<p><strong>只支持全双工链路</strong></p>
<p><strong>要求</strong></p>
<blockquote>
<p><strong>简单</strong>    对于链路层的帧,无需纠错,无需序号,无需流量控制。</p>
<p><strong>封装成帧</strong>     帧定界符</p>
<p><strong>透明传输</strong>     与帧定界符一样比特组合的数据应该如何处理:异步线路用字节填充,同步线路用比特填充。</p>
<p><strong>多种网络层协议</strong>    封装的IP数据报可以采用多种协议。</p>
<p><strong>多种类型链路</strong>    串行/并行,同步/异步,电/光..</p>
<p><strong>差错检测</strong>    错就丢弃。</p>
<p><strong>检测连接状态</strong>    链路是否正常工作。</p>
<p><strong>最大传送单元</strong>    数据部分最大长度MTU.</p>
<p><strong>网络层地址协商</strong>    知道通信双方的网络层地址。</p>
<p><strong>数据压缩协商</strong></p>
</blockquote>
<p><strong>不要求</strong></p>
<blockquote>
<p>纠错</p>
<p>流量控制</p>
<p>序号</p>
<p>不支持多点线路</p>
</blockquote>
<h4 id="PPP协议的三个组成部分"><a href="#PPP协议的三个组成部分" class="headerlink" title="PPP协议的三个组成部分"></a>PPP协议的三个组成部分</h4><blockquote>
<ol>
<li>一个将IP数据报封装到串行链路(同步串行/异步串行)的方法。</li>
<li>链路控制协议<strong>LCP</strong>:建立并维护数据链路连接。<strong>身份验证</strong></li>
<li>网络控制协议<strong>NCP</strong>: PPP可支持多种网络层协议,每个不同的网络层协议都要一个相应的NCP来配置,为网络层协议建立和配置逻辑连接。</li>
</ol>
</blockquote>
<h4 id="PPP协议的状态图"><a href="#PPP协议的状态图" class="headerlink" title="PPP协议的状态图"></a>PPP协议的状态图</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/PUebqhQlSlsO.png" alt="mark"></p>
<h4 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/7iFO3B7SjJEV.png" alt="mark"></p>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><blockquote>
<p>高级数据链路控制(High-Level Data Link Control或简称HDLC) ,是一个在同步网上传输数据、面向比特的数据铂路层协议,它是由国际标准化组织(IS0)根据IBM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的.</p>
<p>数据报文可透明传输,用于实现透明传输的”0比特插入法”易于硬件实现</p>
<p><strong>采用全双工通信</strong></p>
<p>所有帧采用<strong>CRC检验</strong>,对信息帧进行顺序<strong>编号</strong>,可防止漏收或重份,传输可靠性高。</p>
</blockquote>
<h4 id="HDLC的站"><a href="#HDLC的站" class="headerlink" title="HDLC的站"></a>HDLC的站</h4><blockquote>
<ul>
<li><p>主站</p>
</li>
<li><p>从站</p>
</li>
<li><p>复合站</p>
</li>
</ul>
<ol>
<li><p>主站的主要功能是发送命令(包括数据信息)帧、接收响应帧,并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</p>
</li>
<li><p>从站的主要功能是接收由主站发来的命令帧,向主站发送响应帧,并且配合主站参与差错恢复等链路控制。</p>
</li>
<li><p>复合站的主要功能是既能发送,又能接收命令帧和响应帧,并且负责整个链路的控制。</p>
</li>
</ol>
<p><strong>三种数据操作方式:</strong></p>
<ol>
<li>正常响应方式</li>
<li>异步平衡方式</li>
<li>异步响应方式</li>
</ol>
</blockquote>
<h4 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h4><blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/jcI6yjCCBTl3.png" alt="mark"></p>
<ul>
<li>信息帧(1)第1位为<strong>0</strong>,用来<strong>传输数据信息</strong>,或使用捎带技术对数据进行确认</li>
<li>监督帧(S) <strong>10</strong>,用于<strong>流量控制和差错控制</strong>,执行对信息帧的确认、请求重发和请求暂停发送等功能</li>
<li>无编号帧(U) <strong>11</strong>,用于提供对<strong>链路</strong>的建立、拆除等多种控制功能。</li>
</ul>
</blockquote>
<h3 id="PPP协议-amp-HDLC协议"><a href="#PPP协议-amp-HDLC协议" class="headerlink" title="PPP协议&amp;HDLC协议"></a>PPP协议&amp;HDLC协议</h3><p><strong>相同</strong></p>
<blockquote>
<p>HDLC, PPP只支持全双工链路。</p>
<p>都可以实现透明传输。</p>
<p>都可以实现差错检测,但不纠正差错。</p>
</blockquote>
<p><strong>不同</strong></p>
<table>
<thead>
<tr>
<th>PPP协议</th>
<th>面向字节</th>
<th>2B协议字段</th>
<th>无序号和确认机制</th>
<th>不可靠</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HDLC协议</strong></td>
<td><strong>面向比特</strong></td>
<td><strong>没有</strong></td>
<td><strong>有编号和确认机制</strong></td>
<td><strong>可靠</strong></td>
</tr>
</tbody></table>
<h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/sH7o37wEabT1.png" alt="mark"></p>
<h3 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h3><p><strong>网桥&amp;交换机</strong></p>
<p><strong>网桥</strong>根据<strong>MAC帧的目的地址</strong>对帧进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时,并不向所有接口转发此帧,而是先检查此帧的目的MAC地址,然后再确定将该帧转发到哪一个接口,或者是把它丢弃(即过滤)。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/xd1Twm6d3qcH.png" alt="mark"></p>
<p>网桥优点:</p>
<ol>
<li>过滤通信量,增大吞吐量。</li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li>
</ol>
<p>网段: 一般指一个计算机网络中使用同一物理层设备, (传输介质,中继器,集线器等)能够直接通讯的那一部分。</p>
<h3 id="网桥分类–透明网桥"><a href="#网桥分类–透明网桥" class="headerlink" title="网桥分类–透明网桥"></a>网桥分类–透明网桥</h3><p>透明网桥: “透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥,是一种即插即用设备-自学  习。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/2oFuXlaHlF6t.png" alt="mark"></p>
<h3 id="网桥分类–源路由网桥"><a href="#网桥分类–源路由网桥" class="headerlink" title="网桥分类–源路由网桥"></a>网桥分类–源路由网桥</h3><p>源路由网桥:在发送帧时,把详细的最佳路由信息(路由最少/时间最短)放在帧的首部中。</p>
<p>方法:源站以广播方式向欲通信的目的站发送一个发现帧。</p>
<h3 id="多接口网桥–以太网交换机"><a href="#多接口网桥–以太网交换机" class="headerlink" title="多接口网桥–以太网交换机"></a>多接口网桥–以太网交换机</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200418/M27o3BorMGQ4.png" alt="mark"></p>
<p><strong>两种交换方式</strong></p>
<blockquote>
<ul>
<li><strong>直通式交换机</strong> 查完目的地址(6B)就立刻转发。延迟小,可靠性低,无法支持具有不同速率的端口的交换。</li>
<li><strong>存储转发式交换机</strong> 将帧放入高速缓存,并检查否正确,正确则转发,错误则丢弃。延迟大,可靠性高,可以支持具有不同速率的端口的交换。</li>
</ul>
</blockquote>
<h3 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h3><ul>
<li><strong>冲突域</strong>:在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</li>
<li><strong>广播域</strong>:网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号,所有能接收收到这个信号的设备范围称为一个广播域。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>能否隔离冲突域</th>
<th>能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td>物理层设备【傻瓜】(中继器、集线器)</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>链路层设备【路人】（网桥、交换机）</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>网络层设备【大佬】（路由器）</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记2</title>
    <url>/lzfangwen.github.io/2020/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><h3 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/CPvLE6vyYds2.png" alt="mark"></p>
<a id="more"></a>

<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p>通信的目的是传送消息</p>
<p><strong>数据</strong>:传送信息的实体,通常是有意义的符号序列。</p>
<p><strong>信号</strong>:数据的电气/电磁的表现,是数据在传输过程中的存在形式。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/N1nHo1I7kInr.png" alt="mark"></p>
<p><strong>信源</strong>:产生和发送数据的源头。</p>
<p><strong>信宿</strong>:接收数据的终点。</p>
<p><strong>信道</strong>:信号的传输媒介。一般用来表示向某一个方向传送信息的介质,因此一条通信线路往往包含一条发送信道和一条接收信道。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/lJeU3FYMQMf8.png" alt="mark"></p>
<h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><p>从通信双方信息的交换方式看，可以有三种基本方式：</p>
<ol>
<li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互,仅需要<strong>一条</strong>信道。</li>
<li><strong>半双工通信</strong>：通信的双方都可以发送或接收信息,但任何一方都不能同时发送和接收,需要<strong>两条</strong>信道。</li>
<li><strong>全双工通信</strong>：通信双方可以同时发送和接受信息,也需要<strong>两条</strong>信道。</li>
</ol>
<h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><ol>
<li><p><strong>串行传输</strong>：速度<strong>慢</strong>，费用<strong>低</strong>，适合<strong>远</strong>距离</p>
</li>
<li><p><strong>并行传输</strong>：速度<strong>快</strong>，费用<strong>高</strong>，适合<strong>近</strong>距离</p>
<p>​                    用于计算机内部数据传输（电脑上的井口 就为并行传输）</p>
</li>
</ol>
<h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p><strong>码元</strong>是指用一个固定时长的信号波形(数字脉冲) ,代表不同离散数值的基本波形,是数字通信中数字信号的计量单位,这个时长内的信号称为k进制码元,而该时长称为码元宽度。当码元的离散状态有M个时(M大于2) ,此时码元为M进制码元。</p>
<p>1码元可以携带多个比特的信息量。例如,在使用二进制编码时,只有两种不同的码元,一种代表0状态,另一种代表1状态</p>
<h3 id="速率、波特、带宽"><a href="#速率、波特、带宽" class="headerlink" title="速率、波特、带宽"></a>速率、波特、带宽</h3><p><strong>速率</strong>也叫数据率,是指数据的<strong>传输速率</strong>,表示单位时间内传输的数据量。可以用<strong>码元传输速</strong>率和<strong>信息传输速率</strong>表示</p>
<ul>
<li><strong>码元传输速率</strong>:别名码元速率、波形速率、调制速率、符号速率等,它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数) ,单位是<strong>波特(Baud)</strong> 。 1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的,也可以是二进制的,但码元速率与进制数无关。====</li>
<li><strong>信息传输速率</strong>:别名信息速率、比特率等,表示单位时间内数字通信系统传输的二进制码元个数(即比特数)·单位是比特/秒(b/s) 。</li>
</ul>
<p>关系:若一个码元携带n bit的信息量,则MBaud的码元传输速率所对应的信息传输速率为MXn bit/s。</p>
<p>带宽:表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>” ,常用来表示网络的通信线路所能输数据的能力。单位是b/s </p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>某一数字通信系统传输的是四进制码元,4s传输了8000个码元,求系统的码元传输速率是多·少?信息传输速率是多少?若另一通信系统传输的是十六进制码元,6s传输了7200个码元,求他的码元传输速率是多少?信息传输速率是多少?并指出哪个系统传输速率快?</p>
<blockquote>
<p>2000波特    4000b/s    1200波特    4800b/s    十六进制最快</p>
<p>四进制码元系统</p>
<p>码元传输速率就是8000/4-2000Baud,信息传输速率就是20001log24=4000b/s</p>
<p>十六进制码元系统</p>
<p>码元传输速率就是7200/6-1200Baud,信息传输速率就是1200*10g216-4800b/s</p>
<p>系统传输的是<strong>比特流</strong>,通常比较的是信息传输速率,所以传输十六进制码元的通信系统传输速率较快,如果用该系统去传输四进制码元会有更高的码元传输速率。</p>
</blockquote>
<h2 id="奈式准则-amp-香农定理"><a href="#奈式准则-amp-香农定理" class="headerlink" title="奈式准则&amp;香农定理"></a>奈式准则&amp;香农定理</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/l7i9Y8YJXplH.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/Npx9FIGhDJRS.png" alt="mark"></p>
<h3 id="奈式准则（奈奎斯特定理）"><a href="#奈式准则（奈奎斯特定理）" class="headerlink" title="奈式准则（奈奎斯特定理）"></a>奈式准则（奈奎斯特定理）</h3><p><strong>奈氏准则</strong>:在理想低通(无噪声,带宽受限)条件下,为了避免码间串扰,极限码元传输速率为2W Baud, w是信道带宽，单位是Hz。</p>
<p><strong>只有这两个公式 带宽才用Hz</strong></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/TOqH4IK30nC0.png" alt="mark"></p>
<ol>
<li>在任何信道中,<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限,就会出现严重的码间串扰问题,使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的频带越宽(即能通过的信号高频分量越多) ,就可以用更高的速率进行码元的有效传输。</li>
<li><strong>奈氏准则给出了码元传输速率的限制,但并没有对信息传输速率给出限制。</strong></li>
<li>由于码元的传输速率受奈氏准则的制约,所以要提高数据的传输速率,就必须设法使每个码元能携带更多个比特的信息量,这就需要采用多元制的调制方法</li>
</ol>
<p>eg.</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/WW0KKr5lKwp1.png" alt="mark"></p>
<h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生,它的瞬时值有时会很大,因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的,若信号较强,那么噪声影响相对较小。因此,信噪比就很重要。<strong>信噪比=信号的平均功率/噪声的平均功率,常记为S/N,并用分贝(dB)作为度量单位</strong>,</p>
<p><strong>即:信噪比（dB）$$=10\log_{10}（S/N）$$ 数值等价</strong></p>
<p><strong>香农定理</strong>:在带宽受限且有噪声的信道中,为了不产生误差,信息的数据传输速率有上限值</p>
<p><strong>信道的极限数据传输速率=$Wlog_2(1+S/N) (b/s)$ ，其中W指带宽（Hz）</strong></p>
<ol>
<li>信道的带宽或信道中的信噪比越大,则信息的极限传输速率就越高。</li>
<li>对一定的传输带宽和一定的信噪比,信息传输速率的上限就确定了。</li>
<li>只要信息的传输速率低于信道的极限传输速率,就一定能找到某种方法来实现无差错的传输。</li>
<li>香农定理得出的为极限信息传输速率,实际信道能达到的传输速率要比它低不少。</li>
<li>从香农定理可以看出,若信道带宽W或信噪比S/N没有上限(不可能) ,那么信道的极限信息传输速率也就没有上限。</li>
</ol>
<p>eg.</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/mq9HLO75vfiL.png" alt="mark"></p>
<h3 id="“nice”和“香浓”"><a href="#“nice”和“香浓”" class="headerlink" title="“nice”和“香浓”"></a>“nice”和“香浓”</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/7GoI2OdlQyxj.png" alt="mark"></p>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h3><p><strong>信道</strong>:信号的传输媒介。一般用来表示向某一个方向传送信息的介质,因此一条通信线路往往包含条发送信道和一条接收信道。</p>
<ul>
<li>传输信号：<ul>
<li>模拟信道(传送模拟信号)</li>
<li>数字信道(传送数字信号)</li>
</ul>
</li>
<li>传输介质：<ul>
<li>无线信道 </li>
<li>有线信道</li>
</ul>
</li>
</ul>
<p>信道上传送的信号</p>
<ul>
<li><p><strong>基带信号</strong></p>
<p>将数字信号1和0直接用两种不同的电压表示,再送到<strong>数字信道</strong>上去传输(<strong>基带传输</strong>)。来自信源的信号,像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号,比如我们说话的声波就是基带信号</p>
</li>
<li><p><strong>宽带信号</strong></p>
<p>将基带信号进行调制后形成的频分复用模拟信号,再传送到<strong>模拟信道</strong>上去传输(<strong>宽带传输</strong>).,把基带信号经过载波调制后,把信号的频率范围搬移到较高的频段以便在信道中传输(即仅频率范围内能够通过信道)</p>
</li>
</ul>
<p>在传输距离较<strong>近</strong>时,计算机网络采用<strong>基带传输</strong>方式(近距离衰减小,从而信号内容不易发生变化)</p>
<p>在传输距离较<strong>远</strong>时,计算机网络采用<strong>宽带传输</strong>方式(远距离衰减大,即使信号变化大也能最后过滤出来基带信号)</p>
<h3 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/EB69RsCbxxVX.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/jMO7XCoQ8wVv.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/UEnmhshwNlcK.png" alt="mark"></p>
<h3 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><ul>
<li><strong>非归零编码【NRZ】</strong><ul>
<li><strong>高1低0</strong>    编码容易实现,但没有检错功能且无法判断一个码元的开始和结束,”以至于<strong>收发双方难以保持同步</strong>。</li>
</ul>
</li>
<li>归零编码【RZ】<ul>
<li>信号电平在一个码元之内都要恢夏到零的这种编码成编码方式。</li>
</ul>
</li>
<li>反向不归零编码【NRZI】<ul>
<li>信号电平翻转表示0,信号电平不变表示1.</li>
</ul>
</li>
<li><strong>曼切斯特编码</strong><ul>
<li>将一个码元分成两个相等的间隔,前一个间隔为低电平后一个间隔为高电平表示码元1;码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变,位中间的跳变既作时钟信号(可用于同步)又作数据信号,但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平,所以数据传输速率只有调制速率的$1/2$</li>
</ul>
</li>
<li><strong>差分曼切斯特编码</strong><ul>
<li><strong>同1异0</strong>    常用于局域网传输,其规则是:若码元为1,则前半个码元的电平与上一个码元的后半个码元的电,平相同,若为0,则相反。该编码的特点是,在每个码元的中间,都有一次电平的跳转,可以实现自同步,且抗干扰性强于曼彻斯特编码</li>
</ul>
</li>
<li>4B/5B编码<ul>
<li>比特流中插入额外的比特以打破-连串的0或1,就是用5个比特来编码4个比特的数据,之后再传给接收方,因此称为4B/5B,编码效率为80%</li>
</ul>
</li>
</ul>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/BTyfKLsdSerN.png" alt="mark"></p>
<h3 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号,而在接收端将模拟信号还原为数字信号,分别对应于调制解调器的调制和解调过程。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/3dNDqruxdEjR.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/iOr7w6xHyQuX.png" alt="mark"></p>
<p>​                    1200*4=4800b/s</p>
<h3 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>计算机内部处理的是二进制数据,处理的都是数字音频,所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现<strong>音频数字化</strong>)</p>
<p>最典型的例子就是对音频信号进行编码的脉码调制(<strong>PCM</strong>) ,在计算机应用中,能够达到<strong>最高保真水平</strong>的就是PCM编码,被广泛用于素材保存及音乐欣赏, CD,DVD以及我们常见的WAV文件中均有应用。它主要包括三步:抽样、量化、编码。</p>
<ol>
<li><p><strong>抽样</strong>:对模拟信号周期性扫描,把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据,要使用采样定理进行采样: </p>
<p>​                            $$f_{采样频率} \geq f{信号最高频率}$$</p>
</li>
<li><p><strong>量化</strong>:把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值,并取整数,这就把连续的电平幅值转换为离散的数字量。</p>
</li>
<li><p><strong>编码</strong>:把量化的结果转换为与之对应的二进制编码。</p>
</li>
</ol>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/SAmVCiJaaMat.png" alt="mark"></p>
<h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性,可能需要较高的频率。这种调制方式还可以使用<strong>频分复用技术</strong>,充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<h2 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h2><p>传输介质也称传输媒体/传输媒介,它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p>
<p><strong>传输媒体并不是物理层</strong>。传输媒体在物理层的下面,因为物理层是体系结构的第一层,因此有时称传输媒体为0层。在传输媒体中传输的是信号,但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了<strong>电气特性</strong>,因此能够识别所传送的比特流。</p>
<p>传输介质</p>
<ul>
<li>导向性传输介质：电磁波被导向沿着固体媒介(铜线/光纤)传播。</li>
<li>非导向性传输介质：自由空间,介质可以是空气、真空、海水等。</li>
</ul>
<h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/pz2JCTyqoQ07.png" alt="mark"></p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。按特性阻抗数值的不同,通常将同轴电缆分,为两类: 502同轴电缆和750同轴电缆。其中, 502同轴电缆主要用于传送基带数字信号,又称为<strong>基带同轴电缆</strong>,它在局域网中得到广泛应用; 752同轴电缆主要用于传送宽带信号,又称为<strong>宽带同轴电缆</strong>,它主要用于有线电视系统。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/53J7HgEVjXB1.png" alt="mark"></p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>光纤通信就是利用光导纤维(简称光纤)传递<strong>光脉冲</strong>来进行通信。有光脉冲表示1,无光脉冲表示0。而可见光的频率大约是$10^8$MHz,因此光纤通信系统的<strong>带宽远远大于</strong>目前其他各种传输媒体的带宽。</p>
<p>光纤在发送端有光源,可以采用发光二极管或半导体激光器,它们在电脉冲作用下能产生出光脉冲;在接收端用光电二极管做成光检测器,在检测到光脉冲时可还原出电脉冲。</p>
<p>光纤主要由<strong>纤芯(实心的</strong>! )和包层构成,光波通过纤芯进行传导,包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时,其折射角将大于入射角。因此,如果入射角足够大,就会出现全反射,即光线碰到包层时候就会折射回纤芯、这个过程不断重复,光也就沿着光纤传输下去。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/pzDmg5D4j8C4.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/Gw2xKokbrzAj.png" alt="mark">光纤的特点：</p>
<ol>
<li>传输损耗小,中继距离长,对远距离传输特别经济。</li>
<li>抗雷电和电磁干扰性能好。</li>
<li>无串音干扰,保密性好,也不易被窃听或截取数据。</li>
<li>体积小,重量轻。</li>
</ol>
<h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/pjRfo1QlRkMJ.png" alt="mark"></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p><strong>诞生原因</strong>:由于存在损耗,在线路上传输的信号功率会逐渐衰减,衰减到一定程度时将造成信号失真,因此会导致接收错误。</p>
<p><strong>中继器的功能</strong>:对信号进行<strong>再生和还原</strong>,对衰减的信号进行放大,保持与原数据相同,以增加信号传输的距离,延长网络的长度。</p>
<p>​                                        <strong>再生数字信号</strong></p>
<p><strong>中继器的两端</strong>:</p>
<ul>
<li>两端的网络部分是网段,而不是子网,适用于完全相同的<strong>两类</strong>网络的互连,且两个网段速率要相同。</li>
<li>中继器只将任何电缆段上的数据发送到另一段电缆上,它仅作用于信号的电气部分,并不管数据中是否有错误数据或不适于网段的数据。</li>
<li>两端可连相同媒体,也可连不同媒体。</li>
<li>中继器两端的网段一定要是同一个协议。(中继器不会存储转发,傻)</li>
</ul>
<p><strong>5-4-3规则</strong>:网络标准中都对信号的延迟范围作了具体的规定,因而中继器只能在规定的范围内进行,否则会网络故障</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200408/AhOklmr7g2ph.png" alt="mark"></p>
<h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><p><strong>集线器的功能</strong>:对信号进行再生<strong>放大转发</strong>,对衰减的信号进行放大,接着转发到其他所有(除输入端口外)处于工作状态的端口上,以增加信号传输的距离,延长网络的长度。不具备信号的定向传送能力,是一个共享式设备。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200409/BkEofHpp8S9K.png" alt="mark"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记8</title>
    <url>/lzfangwen.github.io/2020/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>主要任务是把分组从源端传到目标端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层的传输单位是<strong>数据报</strong></p>
<ul>
<li>功能一：路由选择与分组转发   <strong>最佳路径</strong></li>
<li>功能二：异构网络互联</li>
<li>功能三：拥塞控制<ul>
<li>开环控制</li>
<li>闭环控制</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电话网络</p>
<pre class="mermaid">graph LR
A(建立连接 呼叫/电路建立) --&gt;B(通信)
    B --&gt; C(释放连接/拆除设备)
    F(特点:独占资源)</pre>

<p><strong>优点</strong></p>
<ol>
<li>通信时延小</li>
<li>有序传输</li>
<li>没有冲突</li>
<li>实时性强</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>建立连接时间长</li>
<li>线路独占，使用效率低</li>
<li>无差错控制能力</li>
</ol>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><strong>报文</strong>：源应用发送的信息整体。</p>
<p><strong>优点</strong></p>
<ol>
<li>无需建立连接</li>
<li>存储转发，动态分配线路</li>
<li>线路可靠性较高</li>
<li>线路利用率较高</li>
<li>多目标服务</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>有存储转发时延</li>
<li>报文大小不定，需要网络结点有较大的缓存空间</li>
</ol>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><strong>分组</strong>：把大的数据块分割成小的数据块</p>
<p><strong>优点</strong></p>
<ol>
<li>无需建立连接</li>
<li>存储转发,动态分配线路</li>
<li>线路可靠性较高</li>
<li>线路利用率较高</li>
<li>相对于报文交换，存储管理更容易</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>有存储转发时延</li>
<li>需要传输额外的信息量</li>
<li>乱序到达目的主机时，要对分组排序重组</li>
</ol>
<p><strong>三种数据交换方式比较总结</strong></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200422/jK6r28FwHXMJ.png" alt="mark"></p>
<ol>
<li>报文交换和分组交换都采用存储转发</li>
<li>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</li>
<li>从信道利用率看，报文交换和分组交换优于电路交换，其中分组交换时延更小。</li>
</ol>
<h4 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h4><p><strong>数据报方式</strong>为网络层提供<strong>无连接服务</strong></p>
<blockquote>
<p>无连接服务:不事先为分组的传输确定传输路径,每个分组独立确定传输路径,不同分组传输路径可能不同</p>
</blockquote>
<p><strong>每个分组携带源和目的地址</strong></p>
<p><strong>路由器根据分组的目的地址转发分组</strong>:基于路由协议/算法构建转发表:检索转发表;每个分组独立选路。</p>
<h4 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h4><p><strong>虚电路方式</strong>为网络层提供<strong>连接服务</strong></p>
<blockquote>
<p>连接服务:首先为分组的传输确定传输路径(建立连接) ,然后沿该路径(连接)传输系列分组,系列分组传输路径相同,传输结束后拆除连接。</p>
</blockquote>
<p>虚电路将数据报方式和电路交换方式结合,以发挥两者优点。·</p>
<p>虚电路:一条源主机到目的主机类似于电路的路径(逻辑连接) ,路径上所有结点都要维持这条虚电路的建立,都维持一张虚电路表,每一项记录了一个打开的虚电路的信息。</p>
<p>通信过程:</p>
<pre class="mermaid">graph LR
A(建立连接 /虚电路建立) --&gt;B(数据传输/全双工通信)
    B --&gt; C(释放连接/虚电路释放)</pre>

<p>每个分组携带<strong>虚电路号</strong>,而非自的地址。</p>
<p>源主机发送“呼叫请求”分组并收到“呼叫应答”分组后才算建立连接。</p>
<p>源主机发送“释放请求”分组以拆除虚电路。</p>
<table>
<thead>
<tr>
<th></th>
<th>数据报服务</th>
<th>虚电路服务</th>
</tr>
</thead>
<tbody><tr>
<td>连接的建立</td>
<td>不要</td>
<td>必须有</td>
</tr>
<tr>
<td>目的地址</td>
<td>每个分组都有完整的目的地址</td>
<td>仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td>
</tr>
<tr>
<td>路由选择</td>
<td>每个分组独立地进行路由选择和转发</td>
<td>属于同一条虚电路的分组按照同一路由转发</td>
</tr>
<tr>
<td>分组顺序</td>
<td>不保证分组的有序到达</td>
<td>保证分组的有序到达</td>
</tr>
<tr>
<td>可靠性</td>
<td>不保证可靠通信，可靠性由用户主机来保证</td>
<td>可靠性由网络保证</td>
</tr>
<tr>
<td>对网络故障的适应性</td>
<td>出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td>
<td>所有经过故障点的虚电路均不能正常工作</td>
</tr>
<tr>
<td>差错处理和流量控制</td>
<td>由用户进行流量控制，不保证数据报的可靠性</td>
<td>可由分组交换网负责，也可由用户主机负责</td>
</tr>
</tbody></table>
<h2 id="路由算法和路由协议概述"><a href="#路由算法和路由协议概述" class="headerlink" title="路由算法和路由协议概述"></a>路由算法和路由协议概述</h2><h3 id="静态路由算法（非自适应路由算法）"><a href="#静态路由算法（非自适应路由算法）" class="headerlink" title="静态路由算法（非自适应路由算法）"></a>静态路由算法（非自适应路由算法）</h3><p>管理员手工配置路由信息</p>
<p><strong>优点</strong>：简便、可靠,在负荷稳定、拓扑变化不大的网络中运行效果很好,广泛用于高度安全性的,,络和较小的商业网络。</p>
<p><strong>缺点</strong>：路由更新慢,不适用大型网络。</p>
<h3 id="动态路由算法（自适应路由算法）"><a href="#动态路由算法（自适应路由算法）" class="headerlink" title="动态路由算法（自适应路由算法）"></a>动态路由算法（自适应路由算法）</h3><p>路由器间彼此交换信息,按照路由算法优化出路由表项。</p>
<p>优点：路由更新快,适用大型网络,及时响应链路费用或网络拓扑变化。</p>
<p>缺点：算法复杂,增加网络负担。</p>
<h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p><strong>自治系统AS</strong>:在单一的技术管理下的一组路由器,而这些路由器使用一种AS内部的路电选择协议和共同的度量以确定分组在该AS内的路由,同时还使用一种AS之间的路由协议以确定在AS之间的路由。</p>
<p>一个AS内的所有网络都属于一个行政单位来管辖,一个自治系统的所有路由器在本自治系统内都必须连通。</p>
<h4 id="内部网关协议-IGP"><a href="#内部网关协议-IGP" class="headerlink" title="内部网关协议    IGP"></a>内部网关协议    IGP</h4><p>一个AS内使用的 <strong>RIP</strong>、<strong>OSPF</strong></p>
<h5 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h5><p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议,是因特网的协议标准,最大优点是<strong>简单</strong>。RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>(即一组距离)。</p>
<p>距离:通常为“跳数” ,即从源端口到目的端口所经过的路由器个数,经过一个路由器跳数+1。特别的,从一路由器到直接连接的网络距离为1. RIP允许一条路由最多只能包含15个路由器,因此距离为<strong>16表示网络不可达</strong>。</p>
<p>RIP协议只适用于<strong>小互联网</strong> </p>
<p>和谁交换？</p>
<blockquote>
<p>仅和相邻路由器交换信息</p>
</blockquote>
<p>交换什么？</p>
<blockquote>
<p>交换的信息是自己的路由表</p>
</blockquote>
<p>多久交换？</p>
<blockquote>
<p>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己的路由表 。</p>
</blockquote>
<p>路由器刚开始工作时,只知道直接连接的网络的距离(距离为1) ,接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</p>
<p>经过若干次更新后,所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址,即“收敛”。</p>
<h6 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h6><ol>
<li><p>修改相邻路由器发来的RIP报文中所有表项·对地址为x的相邻路由器发来的RIP报文,修改此报文中的所有项目:把“下一跳”字段中的地址改为x,并把所有的“距离”字段+1<br><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/yj6uOVHW8Owk.png" alt="mark"></p>
</li>
<li><p>对修改后的RIP报文中的每一个项目,进行以下步骤:</p>
<ol>
<li>R1路由表中若没有Net3,则把该项目填入R1路由表</li>
</ol>
</li>
<li><p>R1路由表中若有Net3,则查看下一跳路由器地址:<br>  若下一跳是x,则用收到的项目替换源路由表中的项目;<br>  若下一跳不是x,原来距离比从x走的距离远则更新,否则不作处理</p>
<ol start="3">
<li>若180s还没收到相邻路由器X的更新路由表,则把x记为不可达的路由器,即把距离设置为16.</li>
<li>返回</li>
</ol>
</li>
</ol>
<p>eg.</p>
<blockquote>
<p>已知路由器R6的路由表,现收到相邻路由器R4发来的路由更新信息,试更新路由器R1的路由表</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/1nYParG0LXP1.png" alt="mark"></p>
<p>考虑如图所示的子网,该子网使用了距离-向量算法,下面的向量刚刚到达路由器C :来自B的向量为(5,0,8,12,6,2) ;来自D的向量为(16, 12 ,6, 0,9, 10 ) ;来自E的向量为(7,6, 3,9,0,4),经过测量,C到B,D和E的延迟分别为6 ,3和5,那么C到达所有结点的最短路径是( )。    A. (5,6,0,9,6,2)         B. (11,6,0, 3, 5, 8)</p>
<p>​        C. (5,11,0, 12,8,9)     D. (11,8,0,7, 4,9)</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/vf1h0jrG3l9F.png" alt="mark"></p>
</blockquote>
<h6 id="RIP协议的报文格式"><a href="#RIP协议的报文格式" class="headerlink" title="RIP协议的报文格式"></a>RIP协议的报文格式</h6><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/iV5POQraRT71.png" alt="mark"></p>
<p>RIP的特点：当网络出故障时，需经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由器，<strong>“满收敛”</strong></p>
<h5 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h5><p>开放最短路径优先OSPF协议: “开放”标明OSPF协议不是受某一家厂商控制,而是公开发表的: “最短路径优先”是因为使用了Dijkstra提出的<strong>最短路径算法SPF</strong></p>
<p>OSPF最主要的特征就是使用分布式的<strong>链路状态协议</strong>。</p>
<p>和谁交换？</p>
<blockquote>
<p>使用洪泛法向自治系统内<strong>所有路由器</strong>发送信息,即路由器通过输出端口向所有相邻的路由器发送信息,而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<strong>广播</strong></p>
<p>最终整个区域内所有路由器都得到了这个信息的一个副本。</p>
</blockquote>
<p>交换什么？</p>
<blockquote>
<p>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>(本路由器和哪些路由器相邻,以及该链路的度量/代价–费用、距离、时延、带宽等)。</p>
</blockquote>
<p>多久交换</p>
<blockquote>
<p>只有当<strong>链路状态发生变化时</strong>，路由器才向所有路由器洪泛发送此信息</p>
</blockquote>
<p>最后，所有的路由器都能建立一个<strong>链路状态数据库</strong>，即<strong>全网拓扑图</strong>。</p>
<h6 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h6><ol>
<li><p>每个路由器发现它的邻居结点【HELLO问候分组】,并了解邻居节点的网络地址。</p>
</li>
<li><p>设置到它的每个邻居的成本度量metric</p>
</li>
<li><p>构造【DD数据库描述分组】,向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</p>
</li>
<li><p>如果DD分组中的摘要自己都有,则邻站不做处理;如果有没有的或者是更新的,则发送【LSR链路状态请求分组】请求自己没有的和比自己更新的信息。</p>
</li>
<li><p>收到邻站的LSR分组后,发送【LSU链路状态更新分组】进行更新。6·</p>
</li>
<li><p>更新完毕后,邻站返回一个【LSAck链路状态确认分组】进行确认。</p>
<p>只要一个路由器的链路状态发生变化:</p>
</li>
<li><p>泛洪发送【LSU链路状态更新分组】进行更新。</p>
</li>
<li><p>更新完毕后,其他站返回一个【LSAck链路状态确认分组】进行确认。</p>
</li>
<li><p>使用Dijkstra根据自己的链路状态数据库构造到其他节间的最短路径。</p>
</li>
</ol>
<h6 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h6><p>为了使OSPF能够用于规模很大的网络, OSPF将一个自治系统再划分为若干个更小的范围,叫做区域。,每一个区域都有一个32位的区域标识符(用点分十进制表示)。区域也不能太大,在一个区域内的路由器最好不超过200个。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/bXCcX7GDYKVO.png" alt="mark"></p>
<h6 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h6><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/H9i0F54Aukvt.png" alt="mark"></p>
<p>OSPF直接用IP数据报传送。</p>
<h6 id="OSPF其他特点"><a href="#OSPF其他特点" class="headerlink" title="OSPF其他特点"></a>OSPF其他特点</h6><ol>
<li>每隔30min,要刷新一次数据库中的链路状态。</li>
<li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态,因而与整个互联网的规模并无直接关系。因此当<strong>互联网规模很大</strong>时, OSPF协议要比距离向量协议RIP好得多。</li>
<li>OSPF不存在坏消息传的慢的问题,它的<strong>收敛速度很快</strong>。</li>
</ol>
<h4 id="外部网关协议-EGP"><a href="#外部网关协议-EGP" class="headerlink" title="外部网关协议    EGP"></a>外部网关协议    EGP</h4><p>AS之间使用的<strong>BGP</strong></p>
<p>和谁交换？</p>
<blockquote>
<p>与其他AS的邻站BGP发言人交换信息</p>
</blockquote>
<p>交换什么？</p>
<blockquote>
<p>交换的是网络可达性的信息，即到达某个网络所要经过的一系列AS</p>
</blockquote>
<p>多久交换？</p>
<blockquote>
<p>发生变化时更新有变化的部分</p>
</blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/GEVVsYqK0HLr.png" alt="mark"></p>
<p>BGP所交换的网络可达性的信息就是要<strong>到达某个网络所要经过的一系列AS</strong>。</p>
<p>当BGP发言人互相交换了网络可达性的信息后,各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。</p>
<h5 id="BGP协议交换信息的过程"><a href="#BGP协议交换信息的过程" class="headerlink" title="BGP协议交换信息的过程"></a>BGP协议交换信息的过程</h5><p>BGP发言人交换路径向量</p>
<p>主干网还可发出通知：“要到达网络NS、N6和N7可沿路径（AS<del>1</del>,AS<del>3</del>）。”</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/IFoOHy7QY6TV.png" alt="mark"></p>
<h5 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h5><p>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息,就要先建立<strong>TCP连接</strong>,即通过TCP传送,然后在此连接上交换BGP报文以建立BGP会话(session),利用BGP会话交换路由信息。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/p6L8M8OUsx7p.png" alt="mark"></p>
<h5 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h5><p>BGP支持CIDR,因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器,以及到达该目的网络所要经过的各个自治系统序列。</p>
<p>在BGP刚刚运行时, BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p>
<h5 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h5><ol>
<li>OPEN (打开)报文:用来与相邻的另一个BGP发言人建立关系,并认证发送方。</li>
<li>UPDATE (更新)报文:通告新路径或撤销原路径。</li>
<li>KEEPALIVE (保活)报文:在无UPDATE时,周期性证实邻站的连通性也作为OPEN的确认。</li>
<li>NOTIFICATION (通知)报文:报告先前报文的差错;也被用于关闭连接。</li>
</ol>
<h4 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a>三种路由协议的比较</h4><ul>
<li><strong>RIP</strong>是一种分布式的基于距离向量的内部网关路由选择协议,通过广播<strong>UDP</strong>报文来交换路由信息。</li>
<li><strong>OSPF</strong>是一个内部网关协议,要交换的信息量较大,应使报文的长度尽量短,所以不使用传输层协议(如UDP,或TCP) ,而是直接采用<strong>IP</strong></li>
<li><strong>BGP</strong>是一个外部网关协议,在不同的自治系统之间交换路由信息,由于网络环境复杂,需要保证可靠传输,所以采用<strong>TCP</strong></li>
</ul>
<table>
<thead>
<tr>
<th>协议</th>
<th>RIP</th>
<th>OSPF</th>
<th>BGP</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>内部</td>
<td>内部</td>
<td>外部</td>
</tr>
<tr>
<td>路由算法</td>
<td>距离-向量</td>
<td>链路状态</td>
<td>路径-向量</td>
</tr>
<tr>
<td>传递协议</td>
<td>UDP</td>
<td>IP</td>
<td>TCP</td>
</tr>
<tr>
<td>路径选择</td>
<td>跳数最少</td>
<td>代价最低</td>
<td>较好，非最佳</td>
</tr>
<tr>
<td>交换结点</td>
<td>和本结点相邻的路由器</td>
<td>网络中的所有的路由器</td>
<td>和本结点相邻的路由器</td>
</tr>
<tr>
<td>交换内容</td>
<td>当前本路由器知道的全部信息，即自己的路由表</td>
<td>与本路由器相邻的所有路由器的链路状态</td>
<td>首次——整个路由表 ，非首次——有变化的部分</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-学习笔记9</title>
    <url>/lzfangwen.github.io/2020/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09/</url>
    <content><![CDATA[<h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><a id="more"></a>

<h3 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/6E4QTjlcqhFw.png" alt="mark"></p>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/FVixb9u3eh9T.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/3sGBWrTSzvd8.png" alt="mark"></p>
<ul>
<li><p>版本: IPV4 / IPv6？</p>
</li>
<li><p>首部长度:单位是4B,最小为5。</p>
</li>
<li><p>区分服务:指示期望获得哪种类型的服务。</p>
</li>
<li><p>总长度:首部+数据,单位是1B</p>
</li>
<li><p>标识：同一数据报的分片使用同一标识</p>
</li>
<li><p>标准：只有2位有意义  x_ _ </p>
<p>中间位DF（Dont‘t Fragment）</p>
<p>​    DF=1，禁止分片</p>
<p>​    DF=0，允许分片</p>
<p>最低位MF（More Fragment）</p>
<p>MF=1，后面“ 还有分片”</p>
<p>MF=0，代表最后一片/没分片</p>
</li>
<li><p>片偏移:指出较长分组分片后,某片在原分组中的相对位置。以<strong>8B为单位</strong>。</p>
<p>除了最后一个分片,每个分片长度一定是8B的整数倍</p>
</li>
<li><p>生存时间(TTL) : IP分组的保质期。经过一个路由器-1,变成0则丢弃。</p>
</li>
<li><p>协议:数据部分的协议。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/nOgPatHj2FY1.png" alt="mark"></p>
</li>
<li><p>首部检验和:只检验首部。</p>
</li>
<li><p>源IP地址和目的IP地址:32位。</p>
</li>
<li><p>可选字段:0-40B ,用来支持排错、测量以及安全等措施。</p>
</li>
<li><p>填充:全0,把首部补成4B的整数倍。</p>
<h4 id="最大传送单元MTU"><a href="#最大传送单元MTU" class="headerlink" title="最大传送单元MTU"></a>最大传送单元MTU</h4></li>
</ul>
<p>链路层数据帧可封装数据的上限</p>
<p>以太网的MTU是1500字节</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/glP4MRMcmVNo.png" alt="mark"></p>
<h4 id="IP数据报分片例题"><a href="#IP数据报分片例题" class="headerlink" title="IP数据报分片例题"></a>IP数据报分片例题</h4><p> <img src="http://qiniuyun.lzfangwen.cn/blog/20200424/piAGbSgxr32D.png" alt="mark"></p>
<p>需要分片为长度不超过1420B的数据报片。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200424/Y8XJ6Tw1XGFg.png" alt="mark"></p>
<table>
<thead>
<tr>
<th></th>
<th>总长度</th>
<th>标识</th>
<th>MF</th>
<th>DF</th>
<th>片偏移</th>
</tr>
</thead>
<tbody><tr>
<td>原始数据报</td>
<td>3820</td>
<td>12345</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>数据报片1</td>
<td>1420</td>
<td>12345</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>数据报片2</td>
<td>1420</td>
<td>12345</td>
<td>1</td>
<td>0</td>
<td>175</td>
</tr>
<tr>
<td>数据报片3</td>
<td>1020</td>
<td>12345</td>
<td>0</td>
<td>0</td>
<td>350</td>
</tr>
</tbody></table>
<p>总长度单位1B</p>
<p>片偏移单位是8B</p>
<p>首部长度单位4B</p>
<p>记忆口诀：一种八片首饰</p>
<h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><p>IP地址:全世界唯一的32位/4字节标识符,标识路由器主机的接口。</p>
<p>IP地址:(&lt;网络号&gt;&lt;主机号&gt;}</p>
<p>11011111 0000001 00000001 00000001=223.1.1.1</p>
<h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/nXboLpPwJ3EH.png" alt="mark"></p>
<h3 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/LbpE9kTgwBuf.png" alt=""></p>
<h3 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/amhFkz0fcsnB.png" alt="mark"></p>
<p>路由器对目的地址是私有IP地址的数据报一律不进行转发</p>
<h3 id="分类的IP地址-1"><a href="#分类的IP地址-1" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/osyzt9QmA3RH.png" alt="mark"></p>
<h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><p>网络地址转换NAT (Network Address Translation) :在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装NAT软件,安装了NAT软件的路由器叫<strong>NAT路由器</strong>,它至少有一个有效的<strong>外部全球IP地址</strong>。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/7FfVk9IYBFP8.png" alt="mark"></p>
<h2 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h2><p>分类的IP地址的弱点</p>
<ol>
<li>IP地址空间的利用率有时很低</li>
<li>两级IP地址不够灵活</li>
</ol>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/iPiXR95co2Jf.png" alt="mark"></p>
<blockquote>
<p>划分后 ，子网号能否全0全1要看情况，主机号不能全0全1。</p>
</blockquote>
<p>某单位划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>网络号对应全为1</p>
<p>主机号对应全为0</p>
<p>子网掩码与IP地址逐位相与，就得到子网网络地址。</p>
<blockquote>
<p>如果对应位都为1结果为1，其他情况为0</p>
</blockquote>
<p>eg.</p>
<blockquote>
<p>“已知IP地址是141.14.72.24),子网掩码是255.255.192.0,求网络地址。</p>
<p>IP地址 ：    1000 1101.0000 1110.0100 1000.0001 1000</p>
<p>子网掩码： 1111 1111.1111.1111.1100 0000.0000 0000</p>
<p>网络地址： 1000 1101.0000 1110.0100 0000.0000 0000</p>
<p>即    141.12.64.0</p>
</blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/q0S4ECkWlz2G.png" alt="mark"></p>
<blockquote>
<p>某主机的IP地址为180.80.77.55，子网掩码为255.255.252.0.若该主机向该主机所在子网发送发送广播分组，则目的地址可以是（）。</p>
<p>A. 180.80.76.0    B. 180.80.76.255    C. 180.80.77.255    D. 180.80.79.255</p>
<p>IP地址：    1011 0100.0101 0000.0100 1101.0011 0111</p>
<p>子网掩码：1111 1111.1111 1111.1111 1100.0000 0000</p>
<p>前22位为网络号，后10位为主机号 广播分组主机号全为1</p>
<p>网络地址：1011 0100.0101 0000.0100 1100.0000 0000</p>
<p>​                   1011 0100.0101 0000.0100 1100.1111 1111                </p>
<p>即    180.80.79.255</p>
<p>结果选B</p>
</blockquote>
<h3 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h3><p>路由表中：</p>
<ol>
<li>目的网络地址</li>
<li>目的网络子网掩码</li>
<li>下一跳地址</li>
</ol>
<p>路由器转发分组的算法：</p>
<ol>
<li>提取目的IP地址</li>
<li>是否直接交付</li>
<li>特定主机路由</li>
<li>检测路由表中有无路径</li>
<li>默认路由0.0.0.0</li>
<li>丢弃,报告转发分组出错</li>
</ol>
<h2 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h2><ol>
<li><p>消除了传统的A类，B类和C类地址以及划分子网的概念</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200425/LEljeyMUMJSu.png" alt="mark"></p>
<p>CIDR记法：IP地址后加上“ / ”，然后写上网络前缀（可以任意长度）的位数。eg. 1028.14.32.0/2</p>
</li>
<li><p>融合子网地址与子网掩码,方便子网划分。</p>
<p>CIDR把<strong>网络前缀都相同</strong>的连续的IP地址组成一个”CIDR地址块”</p>
<p>128.14.35.7/20是某CIDR地址块中的一个地址</p>
<p>​    二进制: <u>10000000 00001110 0010</u>0011 00000111</p>
<p>最小地址: <u>10000000 00001110 0010</u>0000 00000000</p>
<p>​                                    128.14.32.0</p>
<p>最大地址: <u>10000000 00001110 0010</u>1111 11111111</p>
<p>​                                    128.14.47.255</p>
<p>地址块: 128.14.32.0/20  </p>
<p>地址掩码（子网掩码）：</p>
<p>​            1111 1111.1111 1111.1111 0000.0000 0000</p>
</li>
</ol>
<p>eg.</p>
<blockquote>
<p>192.199.170.82/27</p>
<p>前27位位网络前缀  82 二进制 为 101  0010</p>
<p>最小地址 最后8位为 101 0000</p>
<p>​                192.199.170.64</p>
<p>最大地址 最后8位为 101 1111</p>
<p>​                192.199.170.95</p>
</blockquote>
<h3 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h3><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p>
<p>方法 ：将网络前缀缩短。</p>
<h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><p> 使用CIDR时,查找路由表可能得到几个匹配结果,应选择具有最长网络前缀的路由。前缀越长,地址块越小各由越具体。</p>
<p>eg.</p>
<blockquote>
<p>路由器RO的路由表见下表:若进入路由器RO的分组的目的地址为132.19.237.5请问该分红,应该被转发到哪一个下一跳路由器( )。</p>
<p>A. R1    B.R2    C.R3    D.R4</p>
<table>
<thead>
<tr>
<th>目的网络</th>
<th>下一跳</th>
</tr>
</thead>
<tbody><tr>
<td>132.0.0.0/^8^</td>
<td>R1</td>
</tr>
<tr>
<td>132.0.0.0/11</td>
<td>R2</td>
</tr>
<tr>
<td>132.19.232.0/22</td>
<td>R3</td>
</tr>
<tr>
<td>0.0.0.0/0</td>
<td>R4</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>目的网络</th>
<th>132.19.237.5=10000100.000010011.11101101.00000101</th>
</tr>
</thead>
<tbody><tr>
<td>132.0.0.0/8</td>
<td>132.0.0.0/8</td>
</tr>
<tr>
<td>132.0.0.0/11</td>
<td>8132.0.0.0/11</td>
</tr>
<tr>
<td>132.19.232.0/22</td>
<td>132.19.236.0/22 不匹配</td>
</tr>
<tr>
<td>0.0.0.0/0</td>
<td>R4</td>
</tr>
</tbody></table>
<p>1 2选择前缀最长的 选第一个 R1 选A</p>
</blockquote>
<blockquote>
<p>某网络的P地址空间为192.168.5.0/24)采用定长子网划分,子网掩码为255.255. 255.248,则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是( )。</p>
<p>A. 32, 8        B. 32, 6        C. 8, 32        D. 8, 30</p>
<p>192.168.5.0/24</p>
<p><u>1100 0000.1010 1000.0000 0101</u>.0000 0000</p>
<p>1111 1111.1111 1111.1111 1111.<u>1111 1</u>000</p>
<p>子网号为5位 最大子网个数=2^5^=32</p>
<p>主机号位3位  每个子网内的最大可分配地址=2^3^-2=6</p>
<p>选 A</p>
</blockquote>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP高速缓存（IP地址与MAC地址的映射）</p>
<p>由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。</p>
<p>ARP协议：完成主机或路由器IP地址到MAC地址的映射（解决下一跳走哪的问题）</p>
<p>ARP协议使用过程：</p>
<ul>
<li>检查<strong>ARP高速缓存</strong>,有对应表项则写入MAC帧,没有则用目的MAC地址为FFF-F-F-F-F帧封装并广播<strong>ARP请求分组</strong>,<strong>同一局域网</strong>中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组,源主机收到后将此映射<strong>写入ARP缓存</strong>(10-20min更新一次) 。</li>
</ul>
<p>ARP协议4种典型情况:</p>
<ol>
<li>主机A发给本网络上的主机B:用ARP找到主机B的硬件地址</li>
<li>主机A发给另一网络上的主机B:用ARP找到本网络上一个路由器(网关)的硬件地址</li>
<li>路由器发给本网络的主机A:用ARP找到主机A的硬件地址</li>
<li>路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址</li>
</ol>
<p><img src="C:%5CUsers%5C%E9%83%9D%E6%97%8B%E6%96%8C%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426084500561.png" alt="image-20200426084500561"></p>
<p><img src="C:%5CUsers%5C%E9%83%9D%E6%97%8B%E6%96%8C%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426084447188.png" alt="image-20200426084447188"></p>
<p>eg.</p>
<blockquote>
<p>主机发送IP数据报给主机B,经过了5个路由器,请问此过程总共使用了几次ARP协议?</p>
<pre class="mermaid">&gt; graph LR
A[A]--&gt;|1次|B(X)--&gt;|2次|C(X)--&gt;|3次|D(X)--&gt;|4次|E(X)--&gt;|5次|F(X)--&gt;|6次|G[B]
</pre>

<p>一共使用了6次ARP协议</p>
</blockquote>
<h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>主机如何获得IP地址</p>
<blockquote>
<p>静态配置</p>
<p>动态配置</p>
</blockquote>
<p>动态主机配置协议DHCP是<strong>应用层</strong>协议,使用<strong>客户/服务器</strong>方式,客户端和服务端通过<strong>广播</strong>方式进行交互,基于<strong>UDP</strong>.</p>
<p><strong>DHCP</strong>提供<strong>即插即用</strong>联网的机制,主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址,允许<strong>地址重用</strong>,支持<strong>移动用户加入网络</strong>,支持<strong>在用地址续租</strong>。</p>
<ol>
<li><p>主机广播DHCP发现报文</p>
<blockquote>
<p>“有没有DHCP服务器呀? ”</p>
<p>试图找到网络中的服务器,服务器获得一个IP地址。</p>
</blockquote>
</li>
<li><p>DHCP服务器广播DHCP提供报文</p>
<blockquote>
<p>“有! ““有! “ “有! ”</p>
<p>服务器拟分配给主机一个IP地址及相关配置,先到先得。</p>
</blockquote>
</li>
<li><p>主机广播DHCP请求报文</p>
<blockquote>
<p>“我用你给我的IP地址啦? ”</p>
<p>主机向服务器请求提供IP地址。</p>
</blockquote>
</li>
<li><p>DHCP服务器广播DHCP确认报文</p>
<blockquote>
<p>“用吧! “</p>
<p>正式将IP地址分配给主机。</p>
</blockquote>
</li>
</ol>
<p><img src="C:%5CUsers%5C%E9%83%9D%E6%97%8B%E6%96%8C%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426090734622.png" alt="image-20200426090734622"></p>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>网际控制报文协议ICMP</p>
<p>ICMP协议支持主机或路由器：</p>
<pre class="mermaid">graph LR
A(差错或异常报告/网络探询) --&gt;B(发送特定ICMP报文)</pre>

<p><img src="C:%5CUsers%5C%E9%83%9D%E6%97%8B%E6%96%8C%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426091321943.png" alt="image-20200426091321943"></p>
<p>ICMP类别</p>
<ul>
<li>ICMP差错报文</li>
<li>ICMP询问报文</li>
</ul>
<h3 id="ICMP差错报告报文（5种）"><a href="#ICMP差错报告报文（5种）" class="headerlink" title="ICMP差错报告报文（5种）"></a>ICMP差错报告报文（5种）</h3><ol>
<li><p><strong>终点不可达</strong>:当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</p>
<blockquote>
<p><strong>无法交付</strong></p>
</blockquote>
</li>
<li><p><del><strong>源点抑制</strong>:</del>当路由器或主机由于拥塞而丢弃数据报时,就向源点发送源点抑制报文,使源点知道应当把数据报的发送速率放慢。</p>
<blockquote>
<p><strong>拥堵丢数据</strong></p>
<p>不再使用</p>
</blockquote>
</li>
<li><p><strong>时间超过</strong>:当路由器收到生存时间TL-0的数据报时,除丢弃该数据报外,还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时,就把已收到的数据报片都丢弃,并向源点发送时间超过报文。</p>
<blockquote>
<p><strong>TTL=0</strong></p>
</blockquote>
</li>
<li><p><strong>参数问题</strong>:当路由器或目的主机收到的数据报的首部中有的字段的值不正确时,就丢弃该数据报,并向源点发送参数问题报文。</p>
<blockquote>
<p><strong>首部字段有问题</strong></p>
</blockquote>
</li>
<li><p><strong>改变路由(重定向)</strong> :路由器把改变路由报文发送给主机,让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由) 。</p>
<blockquote>
<p><strong>值得更好的路由</strong></p>
</blockquote>
</li>
</ol>
<h3 id="ICMP差错报告报文数据字段"><a href="#ICMP差错报告报文数据字段" class="headerlink" title="ICMP差错报告报文数据字段"></a>ICMP差错报告报文数据字段</h3><p><img src="C:%5CUsers%5C%E9%83%9D%E6%97%8B%E6%96%8C%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426093356278.png" alt="image-20200426093356278"></p>
<h3 id="不发送ICMP差错报文的情况"><a href="#不发送ICMP差错报文的情况" class="headerlink" title="不发送ICMP差错报文的情况"></a>不发送ICMP差错报文的情况</h3><ol>
<li><p>对I<strong>CMP差错报告报文</strong>不再发送ICMP差错报告报文。</p>
</li>
<li><p>对第一个分片的数据报片的所有<strong>后续数据报片</strong>都不发送ICMP差错报告报文。</p>
</li>
<li><p>对具有<strong>组播地</strong>址的数据报都不发送ICMP差错报告报文。</p>
<blockquote>
<p>组播：一对多 区分于广播：一对所有</p>
</blockquote>
</li>
<li><p>对具有<strong>特殊地址</strong>(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</p>
</li>
</ol>
<h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><ol>
<li><p>回送请求和回答报文 </p>
<blockquote>
<p>主机或路由器向特定目的主机发出的询问,收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态。</strong></p>
</blockquote>
</li>
<li><p>时间戳请求和回答报文 </p>
<blockquote>
<p>请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间。</strong></p>
</blockquote>
</li>
<li><p><del>掩码地址请求和回答报文</del></p>
</li>
<li><p><del>路由器询问和通告报文</del></p>
</li>
</ol>
<h3 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h3><ul>
<li><p><strong>PING</strong>    </p>
<p>测试两个主机之间的连通性,使用了<strong>ICMP回送请求和回答报文。</strong></p>
</li>
<li><p><strong>Traceroute</strong>   </p>
<p>跟踪一个分组从源头到终点的路径，使用了<strong>ICMP时间超过差错报告报文</strong></p>
</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>从根本上解决地址耗尽问题</p>
<p>改进首部格式</p>
<p><strong>快速处理/转发数据报</strong></p>
<p><strong>支持Qos</strong></p>
<blockquote>
<p>Qos (Quality of Service,服务质量)指一个网络能够利用各种基础技术,为指定的网络通信提供更好的服务能力,是网络的一种安全机制,是用来解决网络延迟和阻塞等问题的一种技术</p>
</blockquote>
<h3 id="IPv6-数据报格式"><a href="#IPv6-数据报格式" class="headerlink" title="IPv6 数据报格式"></a>IPv6 数据报格式</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200504/is5YqBgdfye6.png" alt="mark"></p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200504/CDGrUTJaxd8x.png" alt="mark"></p>
<ul>
<li><strong>版本</strong>：指明了协议版本，总是6</li>
<li><strong>优先级</strong>：区分数据报的类别和优先级。</li>
<li><strong>流标签</strong>：“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签。</li>
<li><strong>下一个首部</strong>：标识下一个扩展首部或上层协议首部 相当于IPv4的TTL</li>
</ul>
<h3 id="IPv6和IPv4"><a href="#IPv6和IPv4" class="headerlink" title="IPv6和IPv4"></a>IPv6和IPv4</h3><ol>
<li>IPv6将地址从32位（4B）扩大到<strong>128位（16B）</strong>，更大的地址空间</li>
<li>IPV6将IPV4的<strong>校验和字段彻底移除</strong>,以减少每跳的处理时间。</li>
<li>IPV6将IPV4的可选字段移出首部,变成了<strong>扩展首部</strong>,成为灵活的首部格式,路由器通常不对扩展首部进行检查,大大提高了路由器的处理效率。</li>
<li>IPV6支持<strong>即插即用</strong>(即自动配置) ,不需要DHCP协议。</li>
<li>IPV6首部长度必须是<strong>8B的整数倍</strong>, IPV4首部是4B的整数倍。</li>
<li>IPv6<strong>只能在主机处分片</strong>，IPv4可以在路由器和主机处分片</li>
<li>ICMPv6：附加报文类型 ”分组过大 “</li>
<li>IPv6 支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用</li>
<li>IPv6取消了总长度字段，改用有效载荷长度字段</li>
<li>IPv6取消了协议字段，改成下一个首部字段</li>
<li>IPv6取消了服务类型字段</li>
</ol>
<h3 id="IPv6地址标识形式"><a href="#IPv6地址标识形式" class="headerlink" title="IPv6地址标识形式"></a>IPv6地址标识形式</h3><ul>
<li><p><strong>一般形式</strong> </p>
<p><strong>冒号十六进制记法：</strong></p>
<p>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p>
</li>
<li><p><strong>压缩形式：</strong></p>
<p>4BF5:0000:0000:0000:BA 5F:039A:000A:2176</p>
<p>4BF5:0:0:0:BA5F:39A:A:2176</p>
<ul>
<li><p>零压缩:一连串连续的0可以被一对冒号取代。</p>
<p>FF05:0:0:0:0:0:0:B3</p>
<p>FF05::B3</p>
<p>双冒号表示法在一个地址中仅可出现一次。</p>
</li>
</ul>
</li>
</ul>
<h3 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h3><ul>
<li><p><strong>单播</strong></p>
<p>一对一通信    可做源地址+目的地址</p>
</li>
<li><p><strong>多播</strong></p>
<p>一对多通信    可做目的地址</p>
</li>
<li><p><strong>任播</strong></p>
<p>一对多种的一个通信    可做目的地址</p>
</li>
</ul>
<h3 id="IPv6向IPv4过渡的策略"><a href="#IPv6向IPv4过渡的策略" class="headerlink" title="IPv6向IPv4过渡的策略"></a>IPv6向IPv4过渡的策略</h3><ul>
<li><p>双栈协议</p>
<blockquote>
<p>双协议栈技术就是指在一台设备上<strong>同时启用IPV4协议栈和IPv6协议栈</strong>。这样的话,这台设备既能和IPV4网络通信,又能和IPv6网络通信。如果这台设备是一个路由器,那么这台路由器的不同接口上,分别配置了IPV4地址和IPv6地址,并很可能分别连接了IPv4网络和IPV6网络。如果这台设备是一个计算机,那么它将同时拥有IPv4地址和IPV6地址,并具备同时处理这两个协议地址的功能。</p>
</blockquote>
</li>
<li><p>隧道技术</p>
<blockquote>
<p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载),可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包<strong>重新封装</strong>然后通过隧道发送。</p>
</blockquote>
</li>
</ul>
<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h3 id="IP数据报的三种传输方式"><a href="#IP数据报的三种传输方式" class="headerlink" title="IP数据报的三种传输方式"></a>IP数据报的三种传输方式</h3><ul>
<li><p>单播</p>
<blockquote>
<p>用于发送数据包到单个目的地,且每单播发送一份单播报文都使用一个单播iP地址作为目的地址。是一种<strong>点对点</strong>传输方式。</p>
</blockquote>
</li>
<li><p>广播</p>
<blockquote>
<p>广播是指发送数据包到同一广播域或子网内的所有的设备的一种数据传输方式，是一种<strong>点对多点</strong>传输方式，</p>
</blockquote>
</li>
<li><p>组播（多播)</p>
<blockquote>
<p>当网络中的某些用户需要特定数据时组播数据发送者仅发送一次数据,借助组播路由协议为组播数据包建立组播分发树,被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发,是一种<strong>点对多点</strong>传输方式。</p>
</blockquote>
</li>
</ul>
<h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配<strong>一个组播组IP地址(一群共同需求主机的相同标识)。</strong></p>
<p>组播地址范围为224.0.0~239.255.255.255 D类地址) ,一个D类地址表示一个组播组。只能用作分组的<strong>目标地址</strong>。源地址总是为<strong>单播地址</strong>。</p>
<ol>
<li>组播数据报也是”尽最大努力交付“，不提供可靠交付，应用于UDP。</li>
<li>对组播数据报不产生ICMP差错报文</li>
<li>并非所有D类地址都可以作为组播地址</li>
</ol>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200426/UBdQ53dEYRpP.png" alt="mark"></p>
<h3 id="硬件组播"><a href="#硬件组播" class="headerlink" title="硬件组播"></a>硬件组播</h3><p>同单播地址一样,组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值01-00-5E打头,余下的6个十六进制位是根据IP组播组地址的最后23位转换得到的。</p>
<p>TCP/IP协议使用的以太网多播地址的范围是:</p>
<p>从<strong>01-00-5E-00-00-00</strong>到<strong>01-00-5E-7F-FF-FF</strong></p>
<p><img src="C:%5CUsers%5C%E9%83%9D%E6%97%8B%E6%96%8C%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426101402200.png" alt="image-20200426101402200"></p>
<p>收到多播数据报的主机,还要在”IP层利用软件进行过滤,把不是本主机要接收的数据报丢弃。</p>
<h3 id="网际组管理IGMP协议"><a href="#网际组管理IGMP协议" class="headerlink" title="网际组管理IGMP协议"></a>网际组管理IGMP协议</h3><p>IGMP协议让路由器知道本局域网上是否有主机(的进程)参加或退出了某个组播组。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200426/MWhj7eDDorAy.png" alt="mark"></p>
<p><strong>两个阶段</strong></p>
<ol>
<li><p>某主机要加入组播组时,该主机向组播组的组播地址发送一个IGMP报文,声明自己要称为该组的成员。</p>
<p>本地组播路由器收到IGMP报文后,要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>
</li>
<li><p>本地组播路由器周期性探询本地局域网上的主机,以便知道这些主机是否还是组播组的成员。</p>
<p>只要有一个主机对某个组响应,那么组播路由器就认为这个组是活跃的;如果经过几次探询后没有一个主机响应,组播路由器就认为本网络上的没有此组播组的主机,因此就不再把这组的成员关系发给其他的组播路由器。</p>
</li>
</ol>
<p>组播路由器知道的成员关系只是所连接的局域网种有无组播组的成员</p>
<h3 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h3><p>组播路由选择协议目的是找出以源主机为根节点的<strong>组播转发树</strong>。</p>
<p>构造树可以避免在路由器之间兜圈子。</p>
<p>对不同的多播组对应于不同的多播转发树;同一个多播组,对不同的源点也会有不同的多播转发树。</p>
<p>组播路由选择协议常使用的三种算法:</p>
<ul>
<li>基于链路状态的路由选择</li>
<li>基于距离-向量的路由选择</li>
<li>协议无关的组播(稀疏/密集)</li>
</ul>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><h3 id="移动IP-的相关术语"><a href="#移动IP-的相关术语" class="headerlink" title="移动IP 的相关术语"></a>移动IP 的相关术语</h3><p>移动IP技术是移动结点(计算机/服务器等)以<strong>固定的网络IP地址</strong>,实现跨越不同网段的<strong>漫游</strong>功能,并保证了基于网络IP的网络权限在漫游过程中不发生在何改变。</p>
<ul>
<li><strong>移动结点</strong>    具有永久IP地址的移动设备。</li>
<li><strong>归属代理(本地代理)</strong>     一个移动结点拥有的就“居所”称为归属网络,在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</li>
<li><strong>外部代理(外地代理)</strong>     在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</li>
<li><strong>永久地址(归属地址/主地址)</strong>     移动站点在归属网络中的原始地址。</li>
<li><strong>转交地址(辅地址)</strong>       移动站点在外部网络使用的临时地址。</li>
</ul>
<h3 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h3><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/MxpVzi8QE9vs.png" alt="mark"></p>
<p><strong>A刚进入外部网络:</strong></p>
<ol>
<li>在外部代理登记获得一个转交地址,离开时注销。</li>
<li>外地代理向本地代理登记转交地址。</li>
</ol>
<p><strong>B给A发送数据报:</strong></p>
<ol>
<li>本地代理截获数据报。</li>
<li>本地代理再封装数据报,新的数据报目的地址是转交地址,发给外部代理(隧道)</li>
<li>外部代理拆封数据报并发给A。</li>
</ol>
<p><strong>A给B发送数据报:</strong></p>
<ol>
<li>A用自己的主地址作为数据报源地址,用B的IP地址作为数据报的目的地址。</li>
</ol>
<p><strong>A移动到了下一个网络</strong></p>
<ol>
<li>旧的转交地址注销</li>
<li>在新外部代理登记注册一个转交地址。</li>
<li>新外部代理给本地代理发送新的转交地址（覆盖旧的）</li>
</ol>
<p><strong>A回到了归属地址</strong></p>
<ol>
<li>A向本地代理注销转交地址</li>
</ol>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机,其任务是转发分组。</p>
<p>根据所选定的路由选择协议<strong>构造出路由表</strong>,同时经常或定期地和相邻路由器交换路由信息而不断地<strong>更新和维护路由表</strong>。</p>
<p>交换结构:根据<strong>转发表(路由表得来)</strong>对分组进行<strong>转发</strong>。</p>
<p>转发Vs路由选择</p>
<blockquote>
<p>若收到RIP/OSPF分组等,则,把分组送往路由选择处理机;,若收到数据分组,则查找转发表并输出</p>
</blockquote>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/j3yMg5EWEdVY.png" alt="mark"></p>
<h4 id="输入端口对线路上收到的分组的处理"><a href="#输入端口对线路上收到的分组的处理" class="headerlink" title="输入端口对线路上收到的分组的处理"></a>输入端口对线路上收到的分组的处理</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200427/3EBz9F9SilC5.png" alt="mark"></p>
<h4 id="输出端口将交换结构传送的分组发送到线路"><a href="#输出端口将交换结构传送的分组发送到线路" class="headerlink" title="输出端口将交换结构传送的分组发送到线路"></a>输出端口将交换结构传送的分组发送到线路</h4><p><img src="http://qiniuyun.lzfangwen.cn/blog/20200426/Q2KHqrhfCmTa.png" alt="mark"></p>
<p>若路由器处理分组的速率赶不上分组进入队列的速率,则队列的存储空间最终必定减少到零,这就使后面再进入列的分组由于没有存储空间而只能被丢弃。</p>
<p><strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</strong></p>
<h3 id="三层设备的区别"><a href="#三层设备的区别" class="headerlink" title="三层设备的区别"></a>三层设备的区别</h3><ul>
<li>路由器可以互联两个不同网络层协议的网段。</li>
<li>网桥可以互联两个物理层和链路层不同的网段。</li>
<li>集线器不能互联两个物理层不同的网段。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>能否隔离冲突域</th>
<th>能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td>物理层设备【傻瓜】（中继器、集线器）</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>链路层设备【路人】（网桥、交换机）</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>网络层设备【大佬】（路由器）</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h3><p>路由表根据路由表根据路由选择算法得出的,主要用途是路由选择,总用软件来实现。得出的,主要用途是路由选择,总用软件来实现。</p>
<p><img src="http://qiniuyun.lzfangwen.cn/blog/20200426/VlPnyhY3CLny.png" alt="mark"></p>
<p>转发表由路由表得来，可以用软件实现，也可以用特殊的硬件来实现。转发表必须包含完成转发功能所必须的信息，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息的映射。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
